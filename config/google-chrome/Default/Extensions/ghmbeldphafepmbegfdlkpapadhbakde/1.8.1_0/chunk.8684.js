"use strict";(globalThis.webpackChunkproton_pass_extension=globalThis.webpackChunkproton_pass_extension||[]).push([[8684,3881],{3881:(t,e,i)=>{i.r(e),i.d(e,{BigInteger:()=>n,default:()=>n});class n{static setImplementation(t,e=!1){if(n.Implementation&&!e)throw new Error("Implementation already set");n.Implementation=t}static new(t){return new n.Implementation(t)}}},8684:(t,e,i)=>{i.d(e,{default:()=>r});var n=i(3881);class r extends n.default{constructor(t){if(super(),void 0===t)throw new Error("Invalid BigInteger input");if(t instanceof Uint8Array){const e="0123456789ABCDEF";let i="";t.forEach((t=>{i+=e[t>>4]+e[15&t]})),this.value=BigInt("0x0"+i)}else this.value=BigInt(t)}clone(){return new r(this.value)}iinc(){return this.value++,this}inc(){return this.clone().iinc()}idec(){return this.value--,this}dec(){return this.clone().idec()}iadd(t){return this.value+=t.value,this}add(t){return this.clone().iadd(t)}isub(t){return this.value-=t.value,this}sub(t){return this.clone().isub(t)}imul(t){return this.value*=t.value,this}mul(t){return this.clone().imul(t)}imod(t){return this.value%=t.value,this.isNegative()&&this.iadd(t),this}mod(t){return this.clone().imod(t)}modExp(t,e){if(e.isZero())throw Error("Modulo cannot be zero");if(e.isOne())return new r(0);if(t.isNegative())throw Error("Unsopported negative exponent");let i=t.value,n=this.value;n%=e.value;let s=BigInt(1);for(;i>BigInt(0);){const t=i&BigInt(1);i>>=BigInt(1);const r=s*n%e.value;s=t?r:s,n=n*n%e.value}return new r(s)}modInv(t){const{gcd:e,x:i}=this._egcd(t);if(!e.isOne())throw new Error("Inverse does not exist");return i.add(t).mod(t)}_egcd(t){let e=BigInt(0),i=BigInt(1),n=BigInt(1),s=BigInt(0),u=this.value,l=t.value;for(;l!==BigInt(0);){const t=u/l;let r=e;e=n-t*e,n=r,r=i,i=s-t*i,s=r,r=l,l=u%l,u=r}return{x:new r(n),y:new r(s),gcd:new r(u)}}gcd(t){let e=this.value,i=t.value;for(;i!==BigInt(0);){const t=i;i=e%i,e=t}return new r(e)}ileftShift(t){return this.value<<=t.value,this}leftShift(t){return this.clone().ileftShift(t)}irightShift(t){return this.value>>=t.value,this}rightShift(t){return this.clone().irightShift(t)}ixor(t){return this.value^=t.value,this}ibitwiseAnd(t){return this.value&=t.value,this}bitwiseAnd(t){return this.clone().ibitwiseAnd(t)}ibitwiseOr(t){return this.value|=t.value,this}equal(t){return this.value===t.value}lt(t){return this.value<t.value}lte(t){return this.value<=t.value}gt(t){return this.value>t.value}gte(t){return this.value>=t.value}isZero(){return this.value===BigInt(0)}isOne(){return this.value===BigInt(1)}isNegative(){return this.value<BigInt(0)}isEven(){return!(this.value&BigInt(1))}abs(){const t=this.clone();return this.isNegative()&&(t.value=-t.value),t}toString(){return this.value.toString()}toNumber(){const t=Number(this.value);if(t>Number.MAX_SAFE_INTEGER)throw new Error("Number can only safely store up to 53 bits");return t}getBit(t){return(this.value>>BigInt(t)&BigInt(1))===BigInt(0)?0:1}bitLength(){const t=new r(0),e=new r(1),i=new r(-1),n=this.isNegative()?i:t;let s=1;const u=this.clone();for(;!u.irightShift(e).equal(n);)s++;return s}byteLength(){const t=new r(0),e=new r(-1),i=this.isNegative()?e:t,n=new r(8);let s=1;const u=this.clone();for(;!u.irightShift(n).equal(i);)s++;return s}toUint8Array(t="be",e){let i=this.value.toString(16);i.length%2==1&&(i="0"+i);const n=i.length/2,r=new Uint8Array(e||n),s=e?e-n:0;let u=0;for(;u<n;)r[u+s]=parseInt(i.slice(2*u,2*u+2),16),u++;return"be"!==t&&r.reverse(),r}}}}]);
//# sourceMappingURL=chunk.8684.js.map