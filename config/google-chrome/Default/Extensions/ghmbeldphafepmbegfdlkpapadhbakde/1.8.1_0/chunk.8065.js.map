{"version":3,"file":"chunk.8065.js","mappings":"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","sources":["webpack://proton-pass-extension/../../node_modules/jsmimeparser/lib/utils.js","webpack://proton-pass-extension/../../node_modules/jsmimeparser/lib/textDecoders.js","webpack://proton-pass-extension/../../node_modules/jsmimeparser/lib/structuredHeaders.js","webpack://proton-pass-extension/../../node_modules/jsmimeparser/lib/headerParser.js","webpack://proton-pass-extension/../../node_modules/jsmimeparser/lib/rawMimeParser.js","webpack://proton-pass-extension/../../node_modules/jsmimeparser/lib/mailParser.js"],"sourcesContent":["\n/**\n * Decode a quoted-printable buffer into a binary string.\n *\n * @param buffer {BinaryString} The string to decode.\n * @returns {Array(BinaryString, BinaryString)} The first element of the array\n *          is the decoded string. The second element is always the empty\n *          string.\n */\nexport  function decode_qp(buffer) {\n  // Unlike base64, quoted-printable isn't stateful across multiple lines, so\n  // there is no need to buffer input, so we can always ignore more.\n  let decoded = buffer.replace(\n    // Replace either =<hex><hex> or =<wsp>CRLF\n    /=([0-9A-F][0-9A-F]|[ \\t]*(\\r\\n|[\\r\\n]|$))/gi,\n    function(match, param) {\n      // If trailing text matches [ \\t]*CRLF, drop everything, since it's a\n      // soft line break.\n      if (param.trim().length == 0) {\n        return \"\";\n      }\n      return String.fromCharCode(parseInt(param, 16));\n    }\n  );\n  return [decoded, \"\"];\n}\n\n/**\n * Decode a base64 buffer into a binary string. Unlike window.atob, the buffer\n * may contain non-base64 characters that will be ignored.\n *\n * @param buffer {BinaryString} The string to decode.\n * @param more   {Boolean}      If true, we expect that this function could be\n *                              called again and should retain extra data. If\n *                              false, we should flush all pending output.\n * @returns {Array(BinaryString, BinaryString)} The first element of the array\n *          is the decoded string. The second element contains the data that\n *          could not be decoded and needs to be retained for the next call.\n */\nexport function decode_base64(buffer, more) {\n  // Drop all non-base64 characters\n  let sanitize = buffer.replace(/[^A-Za-z0-9+/=]/g, \"\");\n  // Remove harmful `=' chars in the middle.\n  sanitize = sanitize.replace(/=+([A-Za-z0-9+/])/g, \"$1\");\n  // We need to encode in groups of 4 chars. If we don't have enough, leave the\n  // excess for later. If there aren't any more, drop enough to make it 4.\n  let excess = sanitize.length % 4;\n  if (excess != 0 && more) {\n    buffer = sanitize.slice(-excess);\n  } else {\n    buffer = \"\";\n  }\n  sanitize = sanitize.substring(0, sanitize.length - excess);\n  // Delete all unnecessary '====' in padding.\n  sanitize = sanitize.replace(/(====)+$/g, \"\");\n  // Use the atob function we (ought to) have in global scope.\n  return [atob(sanitize), buffer];\n}\n\n/**\n * Converts a binary string into a Uint8Array buffer.\n *\n * @param buffer {BinaryString} The string to convert.\n * @returns {Uint8Array} The converted data.\n */\nexport function stringToUint8Array(buffer) {\n  var typedarray = new Uint8Array(buffer.length);\n  for (var i = 0; i < buffer.length; i++) {\n    typedarray[i] = buffer.charCodeAt(i);\n  }\n  return typedarray;\n}\n\n/**\n * Converts a Uint8Array buffer to a binary string.\n *\n * @param buffer {Uint8Array} The Uint8Array to convert.\n * @returns {string} The converted string.\n */\nexport function uint8ArrayToString(buffer) {\n  var string = \"\";\n  for (let i = 0; i < buffer.length; i += 100) {\n    string += String.fromCharCode.apply(\n      undefined,\n      buffer.subarray(i, i + 100)\n    );\n  }\n  return string;\n}\n\nexport const base64ToUint8Array = (base64) => stringToUint8Array(atob(base64));\n\n/** A list of month names for Date parsing. */\nexport const kMonthNames = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\nexport function concatUint8Arrays(arrays) {\n  if (arrays.length === 1) return arrays[0];\n\n  let totalLength = 0;\n  for (let i = 0; i < arrays.length; i++) {\n      if (!(arrays[i] instanceof Uint8Array)) {\n          throw new Error('concatArrays: Data must be in the form of a Uint8Array');\n      }\n\n      totalLength += arrays[i].length;\n  }\n\n  const result = new Uint8Array(totalLength);\n  let pos = 0;\n  arrays.forEach((element) => {\n      result.set(element, pos);\n      pos += element.length;\n  });\n\n  return result;\n}\n\nexport function uint8ArrayToHex(bytes) {\n  const res = [];\n  for (let c = 0; c < bytes.length; c++) {\n      const hex = bytes[c].toString(16);\n      res.push(hex.length < 2 ? '0' + hex : hex);\n  }\n  return res.join('');\n}\n","import { uint8ArrayToString, base64ToUint8Array } from './utils';\n\nclass UTF7TextDecoder {\n  constructor() {\n    this.collectInput = '';\n    this.decodeString = decodeUtf7;\n  }\n  decode(input, options = {}) {\n    let more = options.stream;\n    // There are cases where this is called without input, to flush the collected input\n    if (input) {\n      this.collectInput += uint8ArrayToString(input);\n    }\n    if (more) {\n      return \"\";\n    }\n    return this.decodeString(this.collectInput);\n  }\n}\n\nclass UTF7ImapTextDecoder extends UTF7TextDecoder {\n  constructor() {\n    super();\n    this.decodeString = decodeUtf7Imap;\n  }\n}\n\nexport function MimeTextDecoder(charset, options) {\n  switch (charset.toLowerCase()) {\n    case \"utf-7\":\n      return new UTF7TextDecoder();\n    case \"utf-7-imap\":\n      return new UTF7ImapTextDecoder();\n    case \"cp932\":\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1511950\n      return new TextDecoder(\"shift_jis\", options);\n    default:\n      return new TextDecoder(charset, options);\n  }\n}\n\n// UTF7 helpers\n\n/**\n * Decode UTF7 string to unicode\n * @see {@link https://github.com/emailjs/emailjs-utf7} for original implementation\n */\n function decodeFromUTF7 (str) {\n  const octets = base64ToUint8Array(str)\n  let output = ''\n\n  // In modified UTF-7, all characters are represented by their two byte Unicode ID.\n  for (let i = 0, len = octets.length; i < len;) {\n    output += String.fromCharCode(octets[i++] << 8 | octets[i++])\n  }\n  return output\n}\n\n/**\n * Decodes UTF-7 string, see RFC 2152\n * @see {@link https://github.com/emailjs/emailjs-utf7} for original implementation\n * @param {String} str String to decode\n */\nexport const decodeUtf7 = str =>\n  str.replace(/\\+([A-Za-z0-9/]*)-?/gi, (_, chunk) => chunk === '' ? '+' : decodeFromUTF7(chunk))\n\n/**\n * Decodes UTF-7 string, see RFC 3501\n * @see {@link https://github.com/emailjs/emailjs-utf7} for original implementation\n * @param {String} str String to decode\n */\nexport const decodeUtf7Imap = str =>\n  str.replace(/&([^-]*)-/g, (_, chunk) => (chunk === '') ? '&' : decodeFromUTF7(chunk.replace(/,/g, '/')))\n","/**\n * This file implements knowledge of how to encode or decode structured headers\n * for several key headers. It is not meant to be used externally to jsmime.\n */\n\nvar structuredDecoders = new Map();\nvar structuredEncoders = new Map();\nvar preferredSpellings = new Map();\n\nfunction addHeader(name, decoder, encoder) {\n  var lowerName = name.toLowerCase();\n  structuredDecoders.set(lowerName, decoder);\n  structuredEncoders.set(lowerName, encoder);\n  preferredSpellings.set(lowerName, name);\n}\n\n// Addressing headers: We assume that they can be specified in 1* form (this is\n// false for From, but it's close enough to the truth that it shouldn't matter).\n// There is no need to specialize the results for the header, so just pun it\n// back to parseAddressingHeader.\nfunction parseAddress(value) {\n  let headerparser = this;\n  return value.reduce(function(results, header) {\n    return results.concat(headerparser.parseAddressingHeader(header, true));\n  }, []);\n}\nfunction writeAddress(value) {\n  // Make sure the input is an array (accept a single entry)\n  if (!Array.isArray(value)) {\n    value = [value];\n  }\n  this.addAddresses(value);\n}\n\n// Addressing headers from RFC 5322:\naddHeader(\"Bcc\", parseAddress, writeAddress);\naddHeader(\"Cc\", parseAddress, writeAddress);\naddHeader(\"From\", parseAddress, writeAddress);\naddHeader(\"Reply-To\", parseAddress, writeAddress);\naddHeader(\"Resent-Bcc\", parseAddress, writeAddress);\naddHeader(\"Resent-Cc\", parseAddress, writeAddress);\naddHeader(\"Resent-From\", parseAddress, writeAddress);\naddHeader(\"Resent-Reply-To\", parseAddress, writeAddress);\naddHeader(\"Resent-Sender\", parseAddress, writeAddress);\naddHeader(\"Resent-To\", parseAddress, writeAddress);\naddHeader(\"Sender\", parseAddress, writeAddress);\naddHeader(\"To\", parseAddress, writeAddress);\n// From RFC 5536:\naddHeader(\"Approved\", parseAddress, writeAddress);\n// From RFC 3798:\naddHeader(\"Disposition-Notification-To\", parseAddress, writeAddress);\n// Non-standard headers:\naddHeader(\"Delivered-To\", parseAddress, writeAddress);\naddHeader(\"Return-Receipt-To\", parseAddress, writeAddress);\n\n// http://cr.yp.to/proto/replyto.html\naddHeader(\"Mail-Reply-To\", parseAddress, writeAddress);\naddHeader(\"Mail-Followup-To\", parseAddress, writeAddress);\n\n// Parameter-based headers. Note that all parameters are slightly different, so\n// we use slightly different variants here.\nfunction parseParameterHeader(value, do2231, do2047) {\n  // Only use the first header for parameters; ignore subsequent redefinitions.\n  return this.parseParameterHeader(value[0], do2231, do2047);\n}\n\n// RFC 2045\nfunction parseContentType(value) {\n  let params = parseParameterHeader.call(this, value, false, false);\n  let origtype = params.preSemi;\n  let parts = origtype.split(\"/\");\n  if (parts.length != 2) {\n    // Malformed. Return to text/plain. Evil, ain't it?\n    params = new Map();\n    parts = [\"text\", \"plain\"];\n  }\n  let mediatype = parts[0].toLowerCase();\n  let subtype = parts[1].toLowerCase();\n  let type = mediatype + \"/\" + subtype;\n  let structure = new Map();\n  structure.mediatype = mediatype;\n  structure.subtype = subtype;\n  structure.type = type;\n  params.forEach(function(value, name) {\n    structure.set(name.toLowerCase(), value);\n  });\n  return structure;\n}\nstructuredDecoders.set(\"Content-Type\", parseContentType);\n\n// Unstructured headers (just decode RFC 2047 for the first header value)\nfunction parseUnstructured(values) {\n  return this.decodeRFC2047Words(values[0]);\n}\nfunction writeUnstructured(value) {\n  this.addUnstructured(value);\n}\n\n// Message-ID headers.\nfunction parseMessageID(values) {\n  // TODO: Proper parsing support for these headers is currently unsupported).\n  return this.decodeRFC2047Words(values[0]);\n}\nfunction writeMessageID(value) {\n  // TODO: Proper parsing support for these headers is currently unsupported).\n  this.addUnstructured(value);\n}\n\n// RFC 5322\naddHeader(\"Comments\", parseUnstructured, writeUnstructured);\naddHeader(\"Keywords\", parseUnstructured, writeUnstructured);\naddHeader(\"Subject\", parseUnstructured, writeUnstructured);\n\n// RFC 2045\naddHeader(\"MIME-Version\", parseUnstructured, writeUnstructured);\naddHeader(\"Content-Description\", parseUnstructured, writeUnstructured);\n\n// RFC 7231\naddHeader(\"User-Agent\", parseUnstructured, writeUnstructured);\n\n// Date headers\nfunction parseDate(values) {\n  return this.parseDateHeader(values[0]);\n}\nfunction writeDate(value) {\n  this.addDate(value);\n}\n\n// RFC 5322\naddHeader(\"Date\", parseDate, writeDate);\naddHeader(\"Resent-Date\", parseDate, writeDate);\n// RFC 5536\naddHeader(\"Expires\", parseDate, writeDate);\naddHeader(\"Injection-Date\", parseDate, writeDate);\naddHeader(\"NNTP-Posting-Date\", parseDate, writeDate);\n\n// RFC 5322\naddHeader(\"Message-ID\", parseMessageID, writeMessageID);\naddHeader(\"Resent-Message-ID\", parseMessageID, writeMessageID);\n\n// Miscellaneous headers (those that don't fall under the above schemes):\n\n// RFC 2047\nstructuredDecoders.set(\"Content-Transfer-Encoding\", function(values) {\n  return values[0].toLowerCase();\n});\nstructuredEncoders.set(\"Content-Transfer-Encoding\", writeUnstructured);\n\n// Some clients like outlook.com send non-compliant References headers that\n// separate values using commas. Also, some clients don't separate References\n// with spaces, since these are optional according to RFC2822. So here we\n// preprocess these headers (see bug 1154521 and bug 1197686).\nfunction preprocessMessageIDs(values) {\n  let msgId = /<[^>]*>/g;\n  let match,\n    ids = [];\n  while ((match = msgId.exec(values)) !== null) {\n    ids.push(match[0]);\n  }\n  return ids.join(\" \");\n}\nstructuredDecoders.set(\"References\", preprocessMessageIDs);\nstructuredDecoders.set(\"In-Reply-To\", preprocessMessageIDs);\n\nexport {\n  structuredDecoders as decoders,\n  structuredEncoders as encoders,\n  preferredSpellings as spellings,\n};\n","/**\n * This file implements the structured decoding of message header fields. It is\n * part of the same system as found in mimemimeutils.js, and occasionally makes\n * references to globals defined in that file or other dependencies thereof. See\n * documentation in that file for more information about external dependencies.\n */\n\nimport { stringToUint8Array, decode_base64, decode_qp, kMonthNames } from \"./utils\";\nimport { MimeTextDecoder } from \"./textDecoders\";\n/**\n* This is the API that we ultimately return.\n*\n* We define it as a global here, because we need to pass it as a |this|\n* argument to a few functions.\n*/\nconst headerparser = {};\n\n/**\n* Clean up characters that could cause display problems since they\n* are not displayed.\n* @param {string} token - The string to be cleaned.\n* @returns {string} The cleaned string.\n*/\nfunction cleanToken(token) {\n  // Replace problematic characters so we don't get unexpected behavior\n  // down the line. These fall into a few categories:\n  // A) \"Separator, space\" (Zs),\n  // B) \"Mark, Nonspacing\" (Mn)\n  // C) \"Other, Control\" (Cc)\n  // D) \"Other, Format\" (Cf)\n  // E) \"Symbol, Other\"\n  // Unfortunately, no support for the needed regexp Unicode property escapes\n  // in our engine. So we need to hand-roll it. Used the regexpu tool for\n  // that: https://mothereff.in/regexpu.\n  // This should be updated regularly, to take into account new additions\n  // to the unicode standard. Last updated July 2019.\n  // For a full list of categories, see http://unicode.org/Public//5.0.0/ucd/UCD.html.\n\n  // -- case A: /\\p{Zs}/u\n  // https://www.fileformat.info/info/unicode/category/Zs/list.htm\n  // https://mothereff.in/regexpu#input=/\\p{Zs}/u&unicodePropertyEscape=1\n  token = token.replace(\n    /[\\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g,\n    \" \"\n  );\n\n  // -- case B: /\\p{Mn}/u\n  // https://www.fileformat.info/info/unicode/category/Mn/list.htm\n  // https://mothereff.in/regexpu#input=/\\p{Mn}/u&unicodePropertyEscape=1\n  // This is a bit more complicated as some of them could be \"real\", so we'll\n  // only remove the ones that are known to show as blank.\n  token = token.replace(\n    /[\\u034F\\u17B4\\u17B5\\u180B-\\u180D\\uFE00-\\uFE0F]/g,\n    \"\"\n  );\n  // \\uE0100-\\uE01EF need to be written using their surrogate code point pairs\n  // until extended Unicode escapes are supported in regexps.\n  // https://www.fileformat.info/info/unicode/char/e0100/index.htm says \\uDB40\\uDD00.\n  // https://www.fileformat.info/info/unicode/char/e01ef/index.htm says \\uDB40\\uDDEF.\n  token = token.replace(/\\uDB40[\\uDD00-\\uDDEF]/g, \"\");\n\n  // -- case C: /\\p{Cc}/u, except Tab/LF/CR\n  // https://www.fileformat.info/info/unicode/category/Cc/list.htm\n  // https://mothereff.in/regexpu#input=/\\p{Cc}/u&unicodePropertyEscape=1\n  // eslint-disable-next-line no-control-regex\n  token = token.replace(/(?![\\t\\n\\r])[\\0-\\x1F\\x7F-\\x9F]/g, \"\");\n\n  // -- case D: /\\p{Cf}/u\n  // https://www.fileformat.info/info/unicode/category/Cf/list.htm\n  // https://mothereff.in/regexpu#input=/\\p{Cf}/u&unicodePropertyEscape=1\n  // Remove all of these except for \\u0600-\\u0605.\n  // XXX: We replace these with spaces (\" \"), not empty strings (\"\").\n  // Notably, for zero width space (\\u200B) replacing with empty space\n  // would later drop real spaces surrounding it. Dunno why.\n  token = token.replace(\n    /(?:[\\xAD\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD80D[\\uDC30-\\uDC38]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F])/g,\n    \" \"\n  );\n\n  // -- case E: problematic symbols\n  // https://www.fileformat.info/info/unicode/category/So/list.htm\n  // Replace U+2800 BRAILLE PATTERN BLANK with space.\n  token = token.replace(/\\u2800/g, \" \");\n\n  return token;\n}\n\n/**\n* Tokenizes a message header into a stream of tokens as a generator.\n*\n* The low-level tokens are meant to be loosely correspond to the tokens as\n* defined in RFC 5322. For reasons of saner error handling, however, the two\n* definitions are not exactly equivalent. The tokens we emit are the following:\n* 1. Special delimiters: Any char in the delimiters string is emitted as a\n*    string by itself. Parsing parameter headers, for example, would use \";=\"\n*    for the delimiter string.\n* 2. Quoted-strings (if opt.qstring is true): A string which is surrounded by\n*    double quotes. Escapes in the string are omitted when returning.\n* 3. Domain Literals (if opt.dliteral is true): A string which matches the\n*    dliteral construct in RFC 5322. Escapes here are NOT omitted.\n* 4. Comments (if opt.comments is true): Comments are handled specially. In\n*    practice, decoding the comments in To headers appears to be necessary, so\n*    comments are not stripped in the output value. Instead, they are emitted\n*    as if they are a special delimiter. However, all delimiters found within a\n*    comment are returned as if they were a quoted string, so that consumers\n*    ignore delimiters within comments. If ignoring comment text completely is\n*    desired, upon seeing a \"(\" token, consumers should ignore all tokens until\n*    a matching \")\" is found (note that comments can be nested).\n* 5. RFC 2047 encoded-words (if opts.rfc2047 is true): These are strings which\n*    are the decoded contents of RFC 2047's =?UTF-8?Q?blah?=-style words.\n* 6. Atoms: Atoms are defined not in the RFC 5322 sense, but rather as the\n*    longest sequence of characters that is neither whitespace nor any of the\n*    special characters above.\n*\n* The intended interpretation of the stream of output tokens is that they are\n* the portions of text which can be safely wrapped in whitespace with no ill\n* effect. The output tokens are either strings (which represent individual\n* delimiter tokens) or instances of a class that has a customized .toString()\n* for output (for quoted strings, atoms, domain literals, and encoded-words).\n* Checking for a delimiter MUST use the strictly equals operator (===). For\n* example, the proper way to call this method is as follows:\n*\n*    for (let token of getHeaderTokens(rest, \";=\", opts)) {\n*      if (token === ';') {\n*        // This represents a literal ';' in the string\n*      } else if (token === '=') {\n*        // This represents a literal '=' in the string\n*      } else {\n*        // If a \";\" qstring was parsed, we fall through to here!\n*        token = token.toString();\n*      }\n*    }\n*\n* This method does not properly tokenize 5322 in all corner cases; however,\n* this is equivalent in those corner cases to an older header parsing\n* algorithm, so the algorithm should be correct for all real-world cases. The\n* corner cases are as follows:\n* 1. Quoted-strings and domain literals are parsed even if they are within a\n*    comment block (we effectively treat ctext as containing qstring).\n* 2. WSP need not be between a qstring and an atom (a\"b\" produces two tokens,\n*    a and b). This is an error case, though.\n* 3. Legacy comments as display names: We recognize address fields with\n*    comments, and (a) either drop them if inside addr-spec or (b) preserve\n*    them as part of the display-name if not. If the display-name is empty\n*    while the last comment is not, we assume it's the legacy form above and\n*    take the comment content as the display-name.\n*\n* @param {String} value      The header value, post charset conversion but\n*                            before RFC 2047 decoding, to be parsed.\n* @param {String} delimiters A set of delimiters to include as individual\n*                            tokens.\n* @param {Object} opts       A set of options selecting what to parse.\n* @param {Boolean} [opts.qstring]  If true, recognize quoted strings.\n* @param {Boolean} [opts.dliteral] If true, recognize domain literals.\n* @param {Boolean} [opts.comments] If true, recognize comments.\n* @param {Boolean} [opts.rfc2047]  If true, parse and decode RFC 2047\n*                                  encoded-words.\n* @returns {(Token|String)[]} An array of Token objects (which have a toString\n*                             method returning their value) or String objects\n*                             (representing delimiters).\n*/\n/* eslint-disable complexity */\nfunction getHeaderTokens(value, delimiters, opts) {\n  // The array of parsed tokens. This method used to be a generator, but it\n  // appears that generators are poorly optimized in current engines, so it was\n  // converted to not be one.\n  let tokenList = [];\n\n  // Represents a non-delimiter token.\n  function Token(token) {\n    // Unescape all quoted pairs. Any trailing \\ is deleted.\n    this.token = token.replace(/\\\\(.?)/g, \"$1\");\n  }\n  Token.prototype.toString = function() {\n    return this.token;\n  };\n\n  // The start of the current token (e.g., atoms, strings)\n  let tokenStart = undefined;\n  // The set of whitespace characters, as defined by RFC 5322\n  let wsp = \" \\t\\r\\n\";\n  // If we are a domain literal ([]) or a quoted string (\"), this is set to the\n  // character to look for at the end.\n  let endQuote = undefined;\n  // The current depth of comments, since they can be nested. A value 0 means we\n  // are not in a comment.\n  let commentDepth = 0;\n\n  // Iterate over every character one character at a time.\n  let length = value.length;\n  for (let i = 0; i < length; i++) {\n    let ch = value[i];\n    // If we see a \\, no matter what context we are in, ignore the next\n    // character.\n    if (ch == \"\\\\\") {\n      i++;\n      continue;\n    }\n\n    // If we are in a qstring or a dliteral, process the character only if it is\n    // what we are looking for to end the quote.\n    if (endQuote !== undefined) {\n      if (ch == endQuote && ch == '\"') {\n        // Quoted strings don't include their delimiters.\n        let text = value.slice(tokenStart + 1, i);\n\n        // If RFC 2047 is enabled, always decode the qstring.\n        if (opts.rfc2047) {\n          text = decodeRFC2047Words(text);\n        }\n\n        tokenList.push(new Token(text));\n        endQuote = undefined;\n        tokenStart = undefined;\n      } else if (ch == endQuote && ch == \"]\") {\n        // Domain literals include their delimiters.\n        tokenList.push(new Token(value.slice(tokenStart, i + 1)));\n        endQuote = undefined;\n        tokenStart = undefined;\n      }\n      // Avoid any further processing.\n      continue;\n    }\n\n    // If we can match the RFC 2047 encoded-word pattern, we need to decode the\n    // entire word or set of words.\n    if (\n      opts.rfc2047 &&\n      ch == \"=\" &&\n      i + 1 < value.length &&\n      value[i + 1] == \"?\"\n    ) {\n      // RFC 2047 tokens separated only by whitespace are conceptually part of\n      // the same output token, so we need to decode them all at once.\n      let encodedWordsRE = /([ \\t\\r\\n]*=\\?[^?]*\\?[BbQq]\\?[^?]*\\?=)+/;\n      let result = encodedWordsRE.exec(value.slice(i));\n      if (result !== null) {\n        // If we were in the middle of a prior token (i.e., something like\n        // foobar=?UTF-8?Q?blah?=), yield the previous segment as a token.\n        if (tokenStart !== undefined) {\n          tokenList.push(new Token(value.slice(tokenStart, i)));\n          tokenStart = undefined;\n        }\n\n        // Find out how much we need to decode...\n        let encWordsLen = result[0].length;\n        let string = decodeRFC2047Words(\n          value.slice(i, i + encWordsLen),\n          \"UTF-8\"\n        );\n        // Don't make a new Token variable, since we do not want to unescape the\n        // decoded string.\n        tokenList.push({\n          toString() {\n            return string;\n          },\n        });\n\n        // Skip everything we decoded. The -1 is because we don't want to\n        // include the starting character.\n        i += encWordsLen - 1;\n        continue;\n      }\n\n      // If we are here, then we failed to match the simple 2047 encoded-word\n      // regular expression, despite the fact that it matched the =? at the\n      // beginning. Fall through and treat the text as if we aren't trying to\n      // decode RFC 2047.\n    }\n\n    // If we reach this point, we're not inside of quoted strings, domain\n    // literals, or RFC 2047 encoded-words. This means that the characters we\n    // parse are potential delimiters (unless we're in comments, where\n    // everything starts to go really wonky). Several things could happen,\n    // depending on the kind of character we read and whether or not we were in\n    // the middle of a token. The three values here tell us what we could need\n    // to do at this point:\n    // tokenIsEnding: The current character is not able to be accumulated to an\n    // atom, so we need to flush the atom if there is one.\n    // tokenIsStarting: The current character could begin an atom (or\n    // anything that requires us to mark the starting point), so we need to save\n    // the location.\n    // isSpecial: The current character is a delimiter that needs to be output.\n    let tokenIsEnding = false,\n      tokenIsStarting = false,\n      isSpecial = false;\n    if (wsp.includes(ch)) {\n      // Whitespace ends current tokens, doesn't emit anything.\n      tokenIsEnding = true;\n    } else if (commentDepth == 0 && delimiters.includes(ch)) {\n      // Delimiters end the current token, and need to be output. They do not\n      // apply within comments.\n      tokenIsEnding = true;\n      isSpecial = true;\n    } else if (opts.qstring && ch == '\"') {\n      // Quoted strings end the last token and start a new one.\n      tokenIsEnding = true;\n      tokenIsStarting = true;\n      endQuote = ch;\n    } else if (opts.dliteral && ch == \"[\") {\n      // Domain literals end the last token and start a new one.\n      tokenIsEnding = true;\n      tokenIsStarting = true;\n      endQuote = \"]\";\n    } else if (opts.comments && ch == \"(\") {\n      // Comments are nested (oh joy). We only really care for the outer\n      // delimiter, though, which also ends the prior token and needs to be\n      // output if the consumer requests it.\n      commentDepth++;\n      if (commentDepth == 1) {\n        tokenIsEnding = true;\n        isSpecial = true;\n      } else {\n        tokenIsStarting = true;\n      }\n    } else if (opts.comments && ch == \")\") {\n      // Comments are nested (oh joy). We only really care for the outer\n      // delimiter, though, which also ends the prior token and needs to be\n      // output if the consumer requests it.\n      if (commentDepth > 0) {\n        commentDepth--;\n      }\n      if (commentDepth == 0) {\n        tokenIsEnding = true;\n        isSpecial = true;\n      } else {\n        tokenIsStarting = true;\n      }\n    } else {\n      // Not a delimiter, whitespace, comment, domain literal, or quoted string.\n      // Must be part of an atom then!\n      tokenIsStarting = true;\n    }\n\n    // If our analysis concluded that we closed an open token, and there is an\n    // open token, then yield that token.\n    if (tokenIsEnding && tokenStart !== undefined) {\n      tokenList.push(new Token(value.slice(tokenStart, i)));\n      tokenStart = undefined;\n    }\n    // If we need to output a delimiter, do so.\n    if (isSpecial) {\n      tokenList.push(ch);\n    }\n    // If our analysis concluded that we could open a token, and no token is\n    // opened yet, then start the token.\n    if (tokenIsStarting && tokenStart === undefined) {\n      tokenStart = i;\n    }\n  }\n\n  // That concludes the loop! If there is a currently open token, close that\n  // token now.\n  if (tokenStart !== undefined) {\n    // Error case: a partially-open quoted string is assumed to have a trailing\n    // \" character.\n    if (endQuote == '\"') {\n      tokenList.push(new Token(value.slice(tokenStart + 1)));\n    } else {\n      tokenList.push(new Token(value.slice(tokenStart)));\n    }\n  }\n  return tokenList;\n}\n/* eslint-enable complexity */\n\n/**\n* Convert a header value into UTF-16 strings by attempting to decode as UTF-8\n* or another legacy charset. If the header is valid UTF-8, it will be decoded\n* as UTF-8; if it is not, the fallbackCharset will be attempted instead.\n*\n* @param {String} headerValue       The header (as a binary string) to attempt\n*                                   to convert to UTF-16.\n* @param {String} [fallbackCharset] The optional charset to try if UTF-8\n*                                   doesn't work.\n* @returns {String} The UTF-16 representation of the string above.\n*/\nfunction convert8BitHeader(headerValue, fallbackCharset) {\n  // Only attempt to convert the headerValue if it contains non-ASCII\n  // characters.\n  if (/[\\x80-\\xff]/.exec(headerValue)) {\n    // First convert the value to a typed-array for MimeTextDecoder.\n    let typedarray = stringToUint8Array(headerValue);\n\n    // Don't try UTF-8 as fallback (redundant), and don't try UTF-16 or UTF-32\n    // either, since they radically change header interpretation.\n    // If we have a fallback charset, we want to know if decoding will fail;\n    // otherwise, we want to replace with substitution chars.\n    let hasFallback =\n      fallbackCharset && !fallbackCharset.toLowerCase().startsWith(\"utf\");\n    let utf8Decoder = new MimeTextDecoder(\"utf-8\", { fatal: hasFallback });\n    try {\n      headerValue = utf8Decoder.decode(typedarray);\n    } catch (e) {\n      // Failed, try the fallback\n      try {\n        let decoder = new MimeTextDecoder(fallbackCharset, {\n          fatal: false,\n        });\n        headerValue = decoder.decode(typedarray);\n      } catch (ex) {}\n    }\n  }\n  return headerValue;\n}\n\n/**\n* Decodes all RFC 2047 encoded-words in the input string. The string does not\n* necessarily have to contain any such words. This is useful, for example, for\n* parsing unstructured headers.\n*\n* @param {String} headerValue The header which may contain RFC 2047 encoded-\n*                             words.\n* @returns {String} A full UTF-16 string with all encoded words expanded.\n*/\nfunction decodeRFC2047Words(headerValue) {\n  // Unfortunately, many implementations of RFC 2047 encoding are actually wrong\n  // in that they split over-long encoded words without regard for whether or\n  // not the split point is in the middle of a multibyte character. Therefore,\n  // we need to be able to handle these situations gracefully. This is done by\n  // using the decoder in streaming mode so long as the next token is another\n  // 2047 token with the same charset.\n  let lastCharset = \"\",\n    currentDecoder = undefined;\n\n  /**\n  * Decode a single RFC 2047 token. This function is inline so that we can\n  * easily close over the lastCharset/currentDecoder variables, needed for\n  * handling bad RFC 2047 productions properly.\n  */\n  function decode2047Token(token, isLastToken) {\n    let tokenParts = token.split(\"?\");\n\n    // If it's obviously not a valid token, return false immediately.\n    if (tokenParts.length != 5 || tokenParts[4] != \"=\") {\n      return false;\n    }\n\n    // The charset parameter is defined in RFC 2231 to be charset or\n    // charset*language. We only care about the charset here, so ignore any\n    // language parameter that gets passed in.\n    let charset = tokenParts[1].split(\"*\", 1)[0];\n    let encoding = tokenParts[2],\n      text = tokenParts[3];\n\n    let buffer;\n    if (encoding == \"B\" || encoding == \"b\") {\n      // Decode base64. If there's any non-base64 data, treat the string as\n      // an illegal token.\n      if (/[^ A-Za-z0-9+/=]/.exec(text)) {\n        return false;\n      }\n\n      // Decode the string\n      buffer = decode_base64(text, false)[0];\n    } else if (encoding == \"Q\" || encoding == \"q\") {\n      // Q encoding here looks a lot like quoted-printable text. The differences\n      // between quoted-printable and this are that quoted-printable allows you\n      // to quote newlines (this doesn't), while this replaces spaces with _.\n      // We can reuse the decode_qp code here, since newlines are already\n      // stripped from the header. There is one edge case that could trigger a\n      // false positive, namely when you have a single = or an = followed by\n      // whitespace at the end of the string. Such an input string is already\n      // malformed to begin with, so stripping the = and following input in that\n      // case should not be an important loss.\n      buffer = decode_qp(text.replace(/_/g, \" \"), false)[0];\n    } else {\n      return false;\n    }\n\n    // Make the buffer be a typed array for what follows\n    let stringBuffer = buffer;\n    buffer = stringToUint8Array(buffer);\n\n    // If we cannot reuse the last decoder, flush out whatever remains.\n    var output = \"\";\n    if (charset != lastCharset && currentDecoder) {\n      output += currentDecoder.decode();\n      currentDecoder = null;\n    }\n\n    // Initialize the decoder for this token.\n    lastCharset = charset;\n    if (!currentDecoder) {\n      try {\n        currentDecoder = new MimeTextDecoder(charset, { fatal: false });\n      } catch (e) {\n        // We don't recognize the charset, so give up.\n        return false;\n      }\n    }\n\n    // Convert this token with the buffer. Note the stream parameter--although\n    // RFC 2047 tokens aren't supposed to break in the middle of a multibyte\n    // character, a lot of software messes up and does so because it's hard not\n    // to (see headeremitter.js for exactly how hard!).\n    // We must not stream ISO-2022-JP if the buffer switches back to\n    // the ASCII state, that is, ends in \"ESC(B\".\n    // Also, we shouldn't do streaming on the last token.\n    let doStreaming;\n    if (\n      isLastToken ||\n      (charset.toUpperCase() == \"ISO-2022-JP\" &&\n        stringBuffer.endsWith(\"\\x1B(B\"))\n    ) {\n      doStreaming = { stream: false };\n    } else {\n      doStreaming = { stream: true };\n    }\n    return output + currentDecoder.decode(buffer, doStreaming);\n  }\n\n  // The first step of decoding is to split the string into RFC 2047 and\n  // non-RFC 2047 tokens. RFC 2047 tokens look like the following:\n  // =?charset?c?text?=, where c is one of B, b, Q, and q. The split regex does\n  // some amount of semantic checking, so that malformed RFC 2047 tokens will\n  // get ignored earlier.\n  let components = headerValue.split(/(=\\?[^?]*\\?[BQbq]\\?[^?]*\\?=)/);\n\n  // Find last RFC 2047 token.\n  let lastRFC2047Index = -1;\n  for (let i = 0; i < components.length; i++) {\n    if (components[i].substring(0, 2) == \"=?\") {\n      lastRFC2047Index = i;\n    }\n  }\n  for (let i = 0; i < components.length; i++) {\n    if (components[i].substring(0, 2) == \"=?\") {\n      let decoded = decode2047Token(components[i], i == lastRFC2047Index);\n      if (decoded !== false) {\n        // If 2047 decoding succeeded for this bit, rewrite the original value\n        // with the proper decoding.\n        components[i] = decoded;\n\n        // We're done processing, so continue to the next link.\n        continue;\n      }\n    } else if (/^[ \\t\\r\\n]*$/.exec(components[i])) {\n      // Whitespace-only tokens get squashed into nothing, so 2047 tokens will\n      // be concatenated together.\n      components[i] = \"\";\n      continue;\n    }\n\n    // If there was stuff left over from decoding the last 2047 token, flush it\n    // out.\n    lastCharset = \"\";\n    if (currentDecoder) {\n      components[i] = currentDecoder.decode() + components[i];\n      currentDecoder = null;\n    }\n  }\n\n  // After the for loop, we'll have a set of decoded strings. Concatenate them\n  // together to make the return value.\n  return components.join(\"\");\n}\n\n// Structured field decoders\n// -------------------------\n\n/**\n* Extract a list of addresses from a header which matches the RFC 5322\n* address-list production, possibly doing RFC 2047 decoding along the way.\n*\n* The output of this method is an array of elements corresponding to the\n* addresses and the groups in the input header. An address is represented by\n* an object of the form:\n* {\n*   name: The display name of the address\n*   email: The address of the object\n* }\n* while a group is represented by an object of the form:\n* {\n*   name: The display name of the group\n*   group: An array of address object for members in the group.\n* }\n*\n* @param {String} header     The MIME header text to be parsed\n* @param {Boolean} doRFC2047 If true, decode RFC 2047 parameters found in the\n*                            header.\n* @returns {(Address|Group)[]} An array of the addresses found in the header,\n*                              where each element is of the form mentioned\n*                              above.\n*/\nfunction parseAddressingHeader(header, doRFC2047) {\n  // Default to true\n  if (doRFC2047 === undefined) {\n    doRFC2047 = true;\n  }\n\n  // The final (top-level) results list to append to.\n  let results = [];\n  // Temporary results\n  let addrlist = [];\n\n  // Build up all of the values\n  let name = \"\",\n    groupName = \"\",\n    localPart = \"\",\n    address = \"\",\n    comment = \"\";\n  // Indicators of current state\n  let inAngle = false,\n    inComment = false,\n    needsSpace = false,\n    afterAddress = false;\n  let preserveSpace = false;\n  let commentClosed = false;\n\n  // RFC 5322 3.4 notes that legacy implementations exist which use a simple\n  // recipient form where the addr-spec appears without the angle brackets,\n  // but includes the name of the recipient in parentheses as a comment\n  // following the addr-spec. While we do not create this format, we still\n  // want to recognize it, though.\n  // Furthermore, despite allowing comments in addresses, RFC 5322 3.4 notes\n  // that legacy implementations may interpret the comment, and thus it\n  // recommends not to use them. (Also, they may be illegal as per RFC 5321.)\n  // While we do not create address fields with comments, we recognize such\n  // comments during parsing and (a) either drop them if inside addr-spec or\n  // (b) preserve them as part of the display-name if not.\n  // If the display-name is empty while the last comment is not, we assume it's\n  // the legacy form above and take the comment content as the display-name.\n  //\n  // When parsing the address field, we at first do not know whether any\n  // strings belong to the display-name (which may include comments) or to the\n  // local-part of an addr-spec (where we ignore comments) until we find an\n  // '@' or an '<' token. Thus, we collect both variants until the fog lifts,\n  // plus the last comment seen.\n  let lastComment = \"\";\n\n  /**\n  * Add the parsed mailbox object to the address list.\n  * If it's in the legacy form above, correct the display-name.\n  * Also reset any faked flags.\n  * @param {String} displayName   display-name as per RFC 5322\n  * @param {String} addrSpec      addr-spec as per RFC 5322\n  */\n  function addToAddrList(displayName, addrSpec) {\n    // Keep the local-part quoted if it needs to be.\n    let lp = addrSpec.substring(0, addrSpec.lastIndexOf(\"@\"));\n    if (/[ !()<>[\\]:;@\\\\,\"]/.exec(lp) !== null) {\n      addrSpec =\n        '\"' +\n        lp.replace(/([\\\\\"])/g, \"\\\\$1\") +\n        '\"' +\n        addrSpec.substring(addrSpec.lastIndexOf(\"@\"));\n    }\n\n    // Replace all whitespace characters with a single whitespace,\n    // to avoid consecutive whitespace and also to normalize tabs and newlines.\n    displayName = displayName.replace(/\\s+/g, \" \").trim();\n\n    if (displayName === \"\" && lastComment !== \"\") {\n      // Take last comment content as the display-name.\n      let offset = lastComment[0] === \" \" ? 2 : 1;\n      displayName = lastComment.substr(\n        offset,\n        lastComment.length - offset - 1\n      );\n    }\n    if (displayName !== \"\" || addrSpec !== \"\") {\n      addrlist.push({ name: displayName, email: addrSpec });\n    }\n    // Clear pending flags and variables.\n    name = localPart = address = lastComment = \"\";\n    inAngle = inComment = needsSpace = afterAddress = false;\n  }\n\n  // Main parsing loop\n  for (let token of getHeaderTokens(header, \":,;<>@\", {\n    qstring: true,\n    comments: true,\n    dliteral: true,\n    rfc2047: doRFC2047,\n  })) {\n    if (token === \":\") {\n      groupName = name;\n      name = \"\";\n      localPart = \"\";\n      // If we had prior email address results, commit them to the top-level.\n      if (addrlist.length > 0) {\n        results = results.concat(addrlist);\n      }\n      addrlist = [];\n    } else if (token === \"<\" && !afterAddress) {\n      if (inAngle) {\n        // Interpret the address we were parsing as a name.\n        if (address.length > 0) {\n          name = address;\n        }\n        localPart = address = \"\";\n      } else {\n        inAngle = true;\n      }\n    } else if (token === \">\" && !afterAddress) {\n      inAngle = false;\n      // Forget addr-spec comments.\n      lastComment = \"\";\n      afterAddress = true;\n    } else if (token === \"(\") {\n      inComment = true;\n      // The needsSpace flag may not always be set even if it should be,\n      // e.g. for a comment behind an angle-addr.\n      // Also, we need to restore the needsSpace flag if we ignore the comment.\n      preserveSpace = needsSpace;\n      if (!needsSpace) {\n        needsSpace = name !== \"\" && name.substr(-1) !== \" \";\n      }\n      comment = needsSpace ? \" (\" : \"(\";\n      commentClosed = false;\n    } else if (token === \")\") {\n      inComment = false;\n      comment += \")\";\n      lastComment = comment;\n      // The comment may be part of the name, but not of the local-part.\n      // Enforce a space behind the comment only when not ignoring it.\n      if (inAngle) {\n        needsSpace = preserveSpace;\n      } else {\n        name += comment;\n        needsSpace = true;\n      }\n      commentClosed = true;\n      continue;\n    } else if (token === \"@\") {\n      if (afterAddress) {\n        continue;\n      }\n      // An @ means we see an email address. If we're not within <> brackets,\n      // then we just parsed an email address instead of a display name. Empty\n      // out the display name for the current production.\n      if (!inAngle) {\n        address = localPart;\n        name = \"\";\n        localPart = \"\";\n        // The remainder of this mailbox is part of an addr-spec.\n        inAngle = true;\n      }\n      address += \"@\";\n    } else if (token === \",\") {\n      // A comma ends the current name. If we have something that's kind of a\n      // name, add it to the result list. If we don't, then our input looks like\n      // To: , , -> don't bother adding an empty entry.\n      addToAddrList(name, address);\n      afterAddress = false;\n    } else if (token === \";\") {\n      // Add pending name to the list\n      addToAddrList(name, address);\n\n      // If no group name was found, treat the ';' as a ','. In any case, we\n      // need to copy the results of addrlist into either a new group object or\n      // the main list.\n      if (groupName === \"\") {\n        results = results.concat(addrlist);\n      } else {\n        results.push({\n          name: groupName,\n          group: addrlist,\n        });\n      }\n      // ... and reset every other variable.\n      addrlist = [];\n      groupName = \"\";\n    } else {\n      // This is either comment content, a quoted-string, or some span of\n      // dots and atoms.\n      token = cleanToken(token.toString());\n\n      // Ignore the needs space if we're a \"close\" delimiter token.\n      let spacedToken = token;\n      if (needsSpace && token && token[0] != \".\") {\n        spacedToken = \" \" + spacedToken;\n      }\n\n      // Which field do we add this data to?\n      if (inComment) {\n        comment += spacedToken;\n      } else if (inAngle) {\n        address += spacedToken;\n      } else {\n        if (!afterAddress) {\n          name += spacedToken;\n        }\n        // Never add a space to the local-part, if we just ignored a comment.\n        if (commentClosed) {\n          localPart += token;\n          commentClosed = false;\n        } else {\n          localPart += spacedToken;\n        }\n      }\n\n      // We need space for the next token if we aren't some kind of comment or\n      // . delimiter.\n      needsSpace = token && token[0] != \".\";\n      // The fall-through case after this resets needsSpace to false, and we\n      // don't want that!\n      continue;\n    }\n\n    // If we just parsed a delimiter, we don't need any space for the next\n    // token.\n    needsSpace = false;\n  }\n\n  // If we're missing the final ';' of a group, assume it was present. Also, add\n  // in the details of any email/address that we previously saw.\n  addToAddrList(name, address);\n  if (groupName !== \"\") {\n    results.push({ name: groupName, group: addrlist });\n    addrlist = [];\n  }\n\n  // Add the current address list build-up to the list of addresses, and return\n  // the whole array to the caller.\n  return results.concat(addrlist);\n}\n\n/**\n* Extract parameters from a header which is a series of ;-separated\n* attribute=value tokens.\n*\n* @param {String} headerValue The MIME header value to parse.\n* @param {Boolean} doRFC2047  If true, decode RFC 2047 encoded-words.\n* @param {Boolean} doRFC2231  If true, decode RFC 2231 encoded parameters.\n* @return {Map(String -> String)} A map of parameter names to parameter values.\n*                                 The property preSemi is set to the token that\n*                                 precedes the first semicolon.\n*/\n/* eslint-disable complexity */\nfunction parseParameterHeader(headerValue, doRFC2047, doRFC2231) {\n  // The basic syntax of headerValue is token [; token = token-or-qstring]*\n  // Copying more or less liberally from nsMIMEHeaderParamImpl:\n  // The first token is the text to the first whitespace or semicolon.\n  var semi = headerValue.indexOf(\";\");\n  let start, rest;\n  if (semi < 0) {\n    start = headerValue;\n    rest = \"\";\n  } else {\n    start = headerValue.substring(0, semi);\n    rest = headerValue.substring(semi); // Include the semicolon\n  }\n  // Strip start to be <WSP><nowsp><WSP>.\n  start = start.trim().split(/[ \\t\\r\\n]/)[0];\n\n  // Decode the the parameter tokens.\n  let opts = { qstring: true, rfc2047: doRFC2047 };\n  // Name is the name of the parameter, inName is true iff we don't have a name\n  // yet.\n  let name = \"\",\n    inName = true;\n  // Matches is a list of [name, value] pairs, where we found something that\n  // looks like name=value in the input string.\n  let matches = [];\n  for (let token of getHeaderTokens(rest, \";=\", opts)) {\n    if (token === \";\") {\n      // If we didn't find a name yet (we have ... tokenA; tokenB), push the\n      // name with an empty token instead.\n      if (name != \"\" && !inName) {\n        matches.push([name, \"\"]);\n      }\n      name = \"\";\n      inName = true;\n    } else if (token === \"=\") {\n      inName = false;\n    } else if (inName && name == \"\") {\n      name = token.toString();\n    } else if (!inName && name != \"\") {\n      token = token.toString();\n      // RFC 2231 doesn't make it clear if %-encoding is supposed to happen\n      // within a quoted string, but this is very much required in practice. If\n      // it ends with a '*', then the string is an extended-value, which means\n      // that its value may be %-encoded.\n      if (doRFC2231 && name.endsWith(\"*\")) {\n        token = token.replace(/%([0-9A-Fa-f]{2})/g, function(\n          match,\n          hexchars\n        ) {\n          return String.fromCharCode(parseInt(hexchars, 16));\n        });\n      }\n      matches.push([name, token]);\n      // Clear the name, so we ignore anything afterwards.\n      name = \"\";\n    } else if (inName) {\n      // We have ...; tokenA tokenB ... -> ignore both tokens\n      name = \"\"; // Error recovery, ignore this one\n    }\n  }\n  // If we have a leftover ...; tokenA, push the tokenA\n  if (name != \"\" && !inName) {\n    matches.push([name, \"\"]);\n  }\n\n  // Now matches holds the parameters, so clean up for RFC 2231. There are three\n  // cases: param=val, param*=us-ascii'en-US'blah, and param*n= variants. The\n  // order of preference is to pick the middle, then the last, then the first.\n  // Note that we already unpacked %-encoded values.\n\n  // simpleValues is just a straight parameter -> value map.\n  // charsetValues is the parameter -> value map, although values are stored\n  // before charset decoding happens.\n  // continuationValues maps parameter -> array of values, with extra properties\n  // valid (if we decided we couldn't do anything anymore) and hasCharset (which\n  // records if we need to decode the charset parameter or not).\n  var simpleValues = new Map(),\n    charsetValues = new Map(),\n    continuationValues = new Map();\n  for (let pair of matches) {\n    let name = pair[0];\n    let value = pair[1];\n    // Get first index, not last index, so we match param*0*= like param*0=.\n    let star = name.indexOf(\"*\");\n    if (star == -1) {\n      // This is the case of param=val. Select the first value here, if there\n      // are multiple ones.\n      if (!simpleValues.has(name)) {\n        simpleValues.set(name, value);\n      }\n    } else if (star == name.length - 1) {\n      // This is the case of param*=us-ascii'en-US'blah.\n      name = name.substring(0, star);\n      // Again, select only the first value here.\n      if (!charsetValues.has(name)) {\n        charsetValues.set(name, value);\n      }\n    } else {\n      // This is the case of param*0= or param*0*=.\n      let param = name.substring(0, star);\n      let entry = continuationValues.get(param);\n      // Did we previously find this one to be bungled? Then ignore it.\n      if (continuationValues.has(param) && !entry.valid) {\n        continue;\n      }\n\n      // If we haven't seen it yet, set up entry already. Note that entries are\n      // not straight string values but rather [valid, hasCharset, param0, ... ]\n      if (!continuationValues.has(param)) {\n        entry = [];\n        entry.valid = true;\n        entry.hasCharset = undefined;\n        continuationValues.set(param, entry);\n      }\n\n      // When the string ends in *, we need to charset decoding.\n      // Note that the star is only meaningful for the *0*= case.\n      let lastStar = name[name.length - 1] == \"*\";\n      let number = name.substring(\n        star + 1,\n        name.length - (lastStar ? 1 : 0)\n      );\n      if (number == \"0\") {\n        entry.hasCharset = lastStar;\n      } else if (\n        number.length == 0 ||\n        (number[0] == \"0\" && number != \"0\") ||\n        !/^[0-9]+$/.test(number)\n      ) {\n        // Is the continuation number illegal?\n        entry.valid = false;\n        continue;\n      }\n      // Normalize to an integer\n      number = parseInt(number, 10);\n\n      // Is this a repeat? If so, bail.\n      if (entry[number] !== undefined) {\n        entry.valid = false;\n        continue;\n      }\n\n      // Set the value for this continuation index. JS's magic array setter will\n      // expand the array if necessary.\n      entry[number] = value;\n    }\n  }\n\n  // Build the actual parameter array from the parsed values\n  var values = new Map();\n  // Simple values have lowest priority, so just add everything into the result\n  // now.\n  for (let pair of simpleValues) {\n    values.set(pair[0], pair[1]);\n  }\n\n  if (doRFC2231) {\n    // Continuation values come next\n    for (let pair of continuationValues) {\n      let name = pair[0];\n      let entry = pair[1];\n      // If we never saw a param*0= or param*0*= value, then we can't do any\n      // reasoning about what it looks like, so bail out now.\n      if (entry.hasCharset === undefined) {\n        continue;\n      }\n\n      // Use as many entries in the array as are valid--if we are missing an\n      // entry, stop there.\n      let valid = true;\n      for (var i = 0; valid && i < entry.length; i++) {\n        if (entry[i] === undefined) {\n          valid = false;\n        }\n      }\n\n      // Concatenate as many parameters as are valid. If we need to decode thec\n      // charset, do so now.\n      let value = entry.slice(0, i).join(\"\");\n      if (entry.hasCharset) {\n        try {\n          value = decode2231Value(value);\n        } catch (e) {\n          // Bad charset, don't add anything.\n          continue;\n        }\n      }\n      // Finally, add this to the output array.\n      values.set(name, value);\n    }\n\n    // Highest priority is the charset conversion.\n    for (let pair of charsetValues) {\n      try {\n        values.set(pair[0], decode2231Value(pair[1]));\n      } catch (e) {\n        // Bad charset, don't add anything.\n      }\n    }\n  }\n\n  // Finally, return the values computed above.\n  values.preSemi = start;\n  return values;\n}\n/* eslint-enable complexity */\n\n/**\n* Convert a RFC 2231-encoded string parameter into a Unicode version of the\n* string. This assumes that percent-decoding has already been applied.\n*\n* @param {String} value The RFC 2231-encoded string to decode.\n* @return The Unicode version of the string.\n*/\nfunction decode2231Value(value) {\n  let quote1 = value.indexOf(\"'\");\n  let quote2 = quote1 >= 0 ? value.indexOf(\"'\", quote1 + 1) : -1;\n\n  let charset = quote1 >= 0 ? value.substring(0, quote1) : \"\";\n  // It turns out that the language isn't useful anywhere in our codebase for\n  // the present time, so we will safely ignore it.\n  // var language = (quote2 >= 0 ? value.substring(quote1 + 2, quote2) : \"\");\n  value = value.substring(Math.max(quote1, quote2) + 1);\n\n  // Convert the value into a typed array for decoding\n  let typedarray = stringToUint8Array(value);\n\n  // Decode the charset. If the charset isn't found, we throw an error. Try to\n  // fallback in that case.\n  return new MimeTextDecoder(charset, { fatal: true }).decode(typedarray, {\n    stream: false,\n  });\n}\n\n// This is a map of known timezone abbreviations, for fallback in obsolete Date\n// productions.\nvar kKnownTZs = {\n  // The following timezones are explicitly listed in RFC 5322.\n  UT: \"+0000\",\n  GMT: \"+0000\",\n  EST: \"-0500\",\n  EDT: \"-0400\",\n  CST: \"-0600\",\n  CDT: \"-0500\",\n  MST: \"-0700\",\n  MDT: \"-0600\",\n  PST: \"-0800\",\n  PDT: \"-0700\",\n  // The following are time zones copied from NSPR's prtime.c\n  AST: \"-0400\", // Atlantic Standard Time\n  NST: \"-0330\", // Newfoundland Standard Time\n  BST: \"+0100\", // British Summer Time\n  MET: \"+0100\", // Middle Europe Time\n  EET: \"+0200\", // Eastern Europe Time\n  JST: \"+0900\", // Japan Standard Time\n};\n\n/**\n* Parse a header that contains a date-time definition according to RFC 5322.\n* The result is a JS date object with the same timestamp as the header.\n*\n* The dates returned by this parser cannot be reliably converted back into the\n* original header for two reasons. First, JS date objects cannot retain the\n* timezone information they were initialized with, so reserializing a date\n* header would necessarily produce a date in either the current timezone or in\n* UTC. Second, JS dates measure time as seconds elapsed from the POSIX epoch\n* excluding leap seconds. Any timestamp containing a leap second is instead\n* converted into one that represents the next second.\n*\n* Dates that do not match the RFC 5322 production are instead attempted to\n* parse using the Date.parse function. The strings that are accepted by\n* Date.parse are not fully defined by the standard, but most implementations\n* should accept strings that look rather close to RFC 5322 strings. Truly\n* invalid dates produce a formulation that results in an invalid date,\n* detectable by having its .getTime() method return NaN.\n*\n* @param {String} header The MIME header value to parse.\n* @returns {Date}        The date contained within the header, as described\n*                        above.\n*/\nfunction parseDateHeader(header) {\n  let tokens = getHeaderTokens(header, \",:\", {}).map(x => x.toString());\n  // What does a Date header look like? In practice, most date headers devolve\n  // into Date: [dow ,] dom mon year hh:mm:ss tzoff [(abbrev)], with the day of\n  // week mostly present and the timezone abbreviation mostly absent.\n\n  // First, ignore the day-of-the-week if present. This would be the first two\n  // tokens.\n  if (tokens.length > 1 && tokens[1] === \",\") {\n    tokens = tokens.slice(2);\n  }\n\n  // If there are too few tokens, the date is obviously invalid.\n  if (tokens.length < 8) {\n    return new Date(NaN);\n  }\n\n  // Save off the numeric tokens\n  let day = parseInt(tokens[0]);\n  // month is tokens[1]\n  let year = parseInt(tokens[2]);\n  let hours = parseInt(tokens[3]);\n  // tokens[4] === ':'\n  let minutes = parseInt(tokens[5]);\n  // tokens[6] === ':'\n  let seconds = parseInt(tokens[7]);\n\n  // Compute the month. Check only the first three digits for equality; this\n  // allows us to accept, e.g., \"January\" in lieu of \"Jan.\"\n  let month = kMonthNames.indexOf(tokens[1].slice(0, 3));\n  // If the month name is not recognized, make the result illegal.\n  if (month < 0) {\n    month = NaN;\n  }\n\n  // Compute the full year if it's only 2 digits. RFC 5322 states that the\n  // cutoff is 50 instead of 70.\n  if (year < 100) {\n    year += year < 50 ? 2000 : 1900;\n  }\n\n  // Compute the timezone offset. If it's not in the form hhmm, convert it to\n  // that form.\n  let tzoffset = tokens[8];\n  if (tzoffset in kKnownTZs) {\n    tzoffset = kKnownTZs[tzoffset];\n  }\n  let decompose = /^([+-])(\\d\\d)(\\d\\d)$/.exec(tzoffset);\n  // Unknown? Make it +0000\n  if (decompose === null) {\n    decompose = [\"+0000\", \"+\", \"00\", \"00\"];\n  }\n  let tzOffsetInMin = parseInt(decompose[2]) * 60 + parseInt(decompose[3]);\n  if (decompose[1] == \"-\") {\n    tzOffsetInMin = -tzOffsetInMin;\n  }\n\n  // How do we make the date at this point? Well, the JS date's constructor\n  // builds the time in terms of the local timezone. To account for the offset\n  // properly, we need to build in UTC.\n  let finalDate = new Date(\n    Date.UTC(year, month, day, hours, minutes, seconds) -\n      tzOffsetInMin * 60 * 1000\n  );\n\n  // Suppose our header was mangled and we couldn't read it--some of the fields\n  // became undefined. In that case, the date would become invalid, and the\n  // indication that it is so is that the underlying number is a NaN. In that\n  // scenario, we could build attempt to use JS Date parsing as a last-ditch\n  // attempt. But it's not clear that such messages really exist in practice,\n  // and the valid formats for Date in ES6 are unspecified.\n  return finalDate;\n}\n\n// Structured header decoding support\n// ----------------------------------\n\n// Load the default structured decoders\nvar structuredDecoders = new Map();\nimport { spellings as preferredSpellings, decoders as headerDecoders} from \"./structuredHeaders\";\nvar forbiddenHeaders = new Set();\nfor (let pair of headerDecoders) {\n  addStructuredDecoder(pair[0], pair[1]);\n  forbiddenHeaders.add(pair[0].toLowerCase());\n}\n\n/**\n* Use an already-registered structured decoder to parse the value of the header\n* into a structured representation.\n*\n* As this method is designed to be used for the internal MIME Parser to convert\n* the raw header values to well-structured values, value is intended to be an\n* array consisting of all occurrences of the header in order. However, for ease\n* of use by other callers, it can also be treated as a string.\n*\n* If the decoder for the header is not found, an exception will be thrown.\n*\n* A large set of headers have pre-defined structured decoders; these decoders\n* cannot be overridden with addStructuredDecoder, as doing so could prevent the\n* MIME or message parsers from working properly. The pre-defined structured\n* headers break down into five clases of results, plus some ad-hoc\n* representations. They are:\n*\n* Addressing headers (results are the same as parseAddressingHeader):\n* - Approved\n* - Bcc\n* - Cc\n* - Delivered-To\n* - Disposition-Notification-To\n* - From\n* - Mail-Reply-To\n* - Mail-Followup-To\n* - Reply-To\n* - Resent-Bcc\n* - Resent-Cc\n* - Resent-From\n* - Resent-Reply-To\n* - Resent-Sender\n* - Resent-To\n* - Return-Receipt-To\n* - Sender\n* - To\n*\n* Date headers (results are the same as parseDateHeader):\n* - Date\n* - Expires\n* - Injection-Date\n* - NNTP-Posting-Date\n* - Resent-Date\n*\n* References headers (results are the same as parseReferencesHeader):\n* - (TODO: Parsing support for these headers is currently unsupported)\n*\n* Message-ID headers (results are the first entry of the result of\n* parseReferencesHeader):\n* - (TODO: Parsing support for these headers is currently unsupported)\n*\n* Unstructured headers (results are merely decoded according to RFC 2047):\n* - Comments\n* - Content-Description\n* - Keywords\n* - Subject\n*\n* The ad-hoc headers and their resulting formats are as follows:\n* Content-Type: returns a JS Map of parameter names (in lower case) to their\n* values, along with the following extra properties defined on the map:\n* - mediatype: the type to the left of '/' (e.g., 'text', 'message')\n* - subtype: the type to the right of '/' (e.g., 'plain', 'rfc822')\n* - type: the full typename (e.g., 'text/plain')\n* RFC 2047 and RFC 2231 decoding is applied where appropriate. The values of\n* the type, mediatype, and subtype attributes are all normalized to lower-case,\n* as are the names of all parameters.\n*\n* Content-Transfer-Encoding: the first value is converted to lower-case.\n*\n* @param {String}       header The name of the header of the values.\n* @param {String|Array} value  The value(s) of the headers, after charset\n*                              conversion (if any) has been applied. If it is\n*                              an array, the headers are listed in the order\n*                              they appear in the message.\n* @returns {Object} A structured representation of the header values.\n*/\nfunction parseStructuredHeader(header, value) {\n  // Enforce that the parameter is an array. If it's a string, make it a\n  // 1-element array.\n  if (typeof value === \"string\" || value instanceof String) {\n    value = [value];\n  }\n  if (!Array.isArray(value)) {\n    throw new TypeError(\"Header value is not an array: \" + value);\n  }\n\n  // Lookup the header in our decoders; if present, use that to decode the\n  // header.\n  let lowerHeader = header.toLowerCase();\n  if (structuredDecoders.has(lowerHeader)) {\n    return structuredDecoders.get(lowerHeader).call(headerparser, value);\n  }\n\n  // If not present, throw an exception.\n  throw new Error(\"Unknown structured header: \" + header);\n}\n\n/**\n* Add a custom structured MIME decoder to the set of known decoders. These\n* decoders are used for {@link parseStructuredHeader} and similar functions to\n* encode richer, more structured values instead of relying on string\n* representations everywhere.\n*\n* Structured decoders are functions which take in a single parameter consisting\n* of an array of the string values of the header, in order that they appear in\n* the message. These headers have had the charset conversion (if necessary)\n* applied to them already. The this parameter of the function is set to be the\n* jsmime.headerparser module.\n*\n* There is a large set of structured decoders built-in to the jsmime library\n* already. As these headers are fundamental to the workings of jsmime,\n* attempting to replace them with a custom version will instead produce an\n* exception.\n*\n* @param {String}                       header  The header name (in any case)\n*                                               for which the decoder will be\n*                                               used.\n* @param {Function(String[] -> Object)} decoder The structured decoder\n*                                               function.\n*/\nfunction addStructuredDecoder(header, decoder) {\n  let lowerHeader = header.toLowerCase();\n  if (forbiddenHeaders.has(lowerHeader)) {\n    throw new Error(\"Cannot override header: \" + header);\n  }\n  structuredDecoders.set(lowerHeader, decoder);\n  if (!preferredSpellings.has(lowerHeader)) {\n    preferredSpellings.set(lowerHeader, header);\n  }\n}\n\nheaderparser.addStructuredDecoder = addStructuredDecoder;\nheaderparser.convert8BitHeader = convert8BitHeader;\nheaderparser.decodeRFC2047Words = decodeRFC2047Words;\nheaderparser.getHeaderTokens = getHeaderTokens;\nheaderparser.parseAddressingHeader = parseAddressingHeader;\nheaderparser.parseDateHeader = parseDateHeader;\nheaderparser.parseParameterHeader = parseParameterHeader;\nheaderparser.parseStructuredHeader = parseStructuredHeader;\nexport default Object.freeze(headerparser);\n","// JavaScript Raw MIME Parser\n// --------------------------\n\n/**\n * The parser implemented in this file produces a MIME part tree for a given\n * input message via a streaming callback interface. It does not, by itself,\n * understand concepts like attachments (hence the term 'Raw'); the consumer\n * must translate output into such a format.\n *\n * Charsets:\n * The MIME specifications permit a single message to contain multiple charsets\n * (or perhaps none) as raw octets. As JavaScript strings are implicitly\n * implemented in UTF-16, it is possible that some engines will attempt to\n * convert these strings using an incorrect charset or simply fail to convert\n * them at all. This parser assumes that its input is in the form of a \"binary\n * string\", a string that uses only the first 256 characters of Unicode to\n * represent the individual octets. To verify that charsets are not getting\n * mangled elsewhere in the pipeline, the auxiliary test file test/data/charsets\n * can be used.\n *\n * This parser attempts to hide the charset details from clients as much as\n * possible. The resulting values of structured headers are always converted\n * into proper Unicode strings before being exposed to clients; getting at the\n * raw binary string data can only be done via getRawHeader. The .charset\n * parameter on header objects, if changed, changes the fallback charset used\n * for headers. It is initialized to the presumed charset of the corresponding\n * part, taking into account the charset and force-charset options of the\n * parser. Body parts are only converted into Unicode strings if the strformat\n * option is set to Unicode. Even then, only the bodies of parts with a media\n * type of text are converted to Unicode strings using available charset data;\n * other parts are retained as Uint8Array objects.\n *\n * Part numbering:\n * Since the output is a streaming format, individual parts are identified by a\n * numbering scheme. The intent of the numbering scheme for parts is to comply\n * with the part numbers as dictated by RFC 3501 as much possible; however,\n * that scheme does have several edge cases which would, if strictly followed,\n * make it impossible to refer to certain parts of the message. In addition, we\n * wish to make it possible to refer to parts which are not discoverable in the\n * original MIME tree but are still viewable as parts. The part numbering\n * scheme is as follows:\n * - Individual sections of a multipart/* body are numbered in increasing order\n *   sequentially, starting from 1. Note that the prologue and the epilogue of\n *   a multipart/* body are not considered entities and are therefore not\n *   included in the part numbering scheme (there is no way to refer to them).\n * - The numbers of multipart/* parts are separated by `.' characters.\n * - The outermost message is referred to by use of the empty string.\n * --> The following segments are not accounted for by IMAP part numbering. <--\n * - The body of any message/rfc822 or similar part is distinguished from the\n *   message part as a whole by appending a `$' character. This does not apply\n *   to the outermost message/rfc822 envelope.\n */\n\nimport { decode_base64, decode_qp, stringToUint8Array, uint8ArrayToString } from \"./utils\";\nimport headerparser from \"./headerParser\";\nimport { spellings }  from \"./structuredHeaders\";\nimport { MimeTextDecoder } from \"./textDecoders\";\n\n/**\n * An object that represents the structured MIME headers for a message.\n *\n * This class is primarily used as the 'headers' parameter in the startPart\n * callback on handlers for MimeParser. As such, it is designed to do the right\n * thing in common cases as much as possible, with some advanced customization\n * possible for clients that need such flexibility.\n *\n * In a nutshell, this class stores the raw headers as an internal Map. The\n * structured headers are not computed until they are actually used, which means\n * that potentially expensive structuring (e.g., doing manual DKIM validation)\n * can be performed as a structured decoder without impeding performance for\n * those who just want a few common headers.\n *\n * The outer API of this class is intended to be similar to a read-only Map\n * object (complete with iterability support), with a few extra properties to\n * represent things that are hard to determine properly from headers. The keys\n * used are \"preferred spellings\" of the headers, although the get and has\n * methods will accept header parameters of any case. Preferred spellings are\n * derived from the name passed to addStructuredDecoder/addStructuredEncoder; if\n * no structured decoder has been registered, then the name capitalizes the\n * first letter of every word in the header name.\n *\n * Extra properties compared to a Map object are:\n * - charset: This field represents the assumed charset of the associated MIME\n *   body. It is prefilled using a combination of the charset and force-charset\n *   options on the associated MimeParser instance as well as attempting to find\n *   a charset parameter in the Content-Type header.\n *\n *   If the force-charset option is false, the charset is guessed first using\n *   the Content-Type header's charset parameter, falling back to the charset\n *   option if it is present. If the force-charset option is true, the charset\n *   is initially set to the charset option. This initial guessed value can be\n *   overridden at any time by simply setting the field on this object.\n *\n *   The charset is better reflected as a parameter of the body rather than the\n *   headers; this is ultimately the charset parameter that will be used if a\n *   body part is being converted to a Unicode strformat. Headers are converted\n *   using headerparser.convert8BitHeader, and this field is used as the\n *   fallbackCharset parameter, which will always to attempt to decode as UTF-8\n *   first (in accordance with RFC 6532) and will refuse to decode as UTF-16 or\n *   UTF-32, as ASCII is not a subset of those charsets.\n *\n * - rawHeaderText: This read-only field contains the original header text from\n *   which headers were parsed, preserving case and whitespace (including\n *   alternate line endings instead of CRLF) exactly. If the header text begins\n *   with the mbox delimiter (i.e., a line that begins with \"From \"), then that\n *   is excluded from the rawHeaderText value and is not reflected anywhere in\n *   this object.\n *\n * - contentType: This field contains the structured representation of the\n *   Content-Type header, if it is present. If it is not present, it is set to\n *   the structured representation of the default Content-Type for a part (as\n *   this data is not easily guessed given only MIME tree events).\n *\n * The constructor for these objects is not externally exported, and thus they\n * can only be created via MimeParser.\n *\n * @param rawHeaderText {BinaryString} The contents of the MIME headers to be\n *                                     parsed.\n * @param options    {Object}          Options for the header parser.\n *   @param options.stripcontinuations {Boolean} If true, elide CRLFs from the\n *                                               raw header output.\n */\nfunction StructuredHeaders(rawHeaderText, options) {\n  // An individual header is terminated by a CRLF, except if the CRLF is\n  // followed by a SP or TAB. Use negative lookahead to capture the latter case,\n  // and don't capture the strings or else split results get nasty.\n  let values = rawHeaderText.split(/(?:\\r\\n|\\n)(?![ \\t])|\\r(?![ \\t\\n])/);\n\n  // Ignore the first \"header\" if it begins with an mbox delimiter\n  if (values.length > 0 && values[0].substring(0, 5) == \"From \") {\n    values.shift();\n    // Elide the mbox delimiter from this._headerData\n    if (values.length == 0) {\n      rawHeaderText = \"\";\n    } else {\n      rawHeaderText = rawHeaderText.substring(\n        rawHeaderText.indexOf(values[0])\n      );\n    }\n  }\n\n  let headers = new Map();\n  for (let i = 0; i < values.length; i++) {\n    // Look for a colon. If it's not present, this header line is malformed,\n    // perhaps by premature EOF or similar.\n    let colon = values[i].indexOf(\":\");\n    let header, val;\n    if (colon >= 0) {\n      header = values[i].substring(0, colon);\n      val = values[i].substring(colon + 1).trim();\n      if (options.stripcontinuations) {\n        val = val.replace(/[\\r\\n]/g, \"\");\n      }\n    } else {\n      header = values[i];\n      val = \"\";\n    }\n\n    // Canonicalize the header in lower-case form.\n    header = header.trim().toLowerCase();\n    // Omit \"empty\" headers\n    if (header == \"\") {\n      continue;\n    }\n\n    // We keep an array of values for each header, since a given header may be\n    // repeated multiple times.\n    if (headers.has(header)) {\n      headers.get(header).push(val);\n    } else {\n      headers.set(header, [val]);\n    }\n  }\n\n  /**\n   * A map of header names to arrays of raw values found in this header block.\n   * @private\n   */\n  this._rawHeaders = headers;\n  /**\n   * Cached results of structured header parsing.\n   * @private\n   */\n  this._cachedHeaders = new Map();\n  Object.defineProperty(this, \"rawHeaderText\", {\n    get() {\n      return rawHeaderText;\n    },\n  });\n  Object.defineProperty(this, \"size\", {\n    get() {\n      return this._rawHeaders.size;\n    },\n  });\n  Object.defineProperty(this, \"charset\", {\n    get() {\n      return this._charset;\n    },\n    set(value) {\n      this._charset = value;\n      // Clear the cached headers, since this could change their values\n      this._cachedHeaders.clear();\n    },\n  });\n\n  // Default to the charset, until the message parser overrides us.\n  if (\"charset\" in options) {\n    this._charset = options.charset;\n  } else {\n    this._charset = null;\n  }\n\n  // If we have a Content-Type header, set contentType to return the structured\n  // representation. We don't set the value off the bat, since we want to let\n  // someone who changes the charset affect the values of 8-bit parameters.\n  Object.defineProperty(this, \"contentType\", {\n    configurable: true,\n    get() {\n      return this.get(\"Content-Type\");\n    },\n  });\n}\n\n/**\n * Get a raw header.\n *\n * Raw headers are an array of the header values, listed in order that they were\n * specified in the header block, and without any attempt to convert charsets or\n * apply RFC 2047 decoding. For example, in the following message (where the\n * <XX> is meant to represent binary-octets):\n *\n * X-Header: Value A\n * X-Header: V<C3><A5>lue B\n * Header2: Q\n *\n * the result of calling getRawHeader('X-Header') or getRawHeader('x-header')\n * would be ['Value A', 'V\\xC3\\xA5lue B'] and the result of\n * getRawHeader('Header2') would be ['Q'].\n *\n * @param headerName {String} The header name for which to get header values.\n * @returns {BinaryString[]} The raw header values (with no charset conversion\n *                           applied).\n */\nStructuredHeaders.prototype.getRawHeader = function(headerName) {\n  return this._rawHeaders.get(headerName.toLowerCase());\n};\n\n/**\n * Retrieve a structured version of the header.\n *\n * If there is a registered structured decoder (registration happens via\n * headerparser.addStructuredDecoder), then the result of calling that decoder\n * on the charset-corrected version of the header is returned. Otherwise, the\n * values are charset-corrected and RFC 2047 decoding is applied as if the\n * header were an unstructured header.\n *\n * A substantial set of headers have pre-registed structured decoders, which, in\n * some cases, are unable to be overridden due to their importance in the\n * functioning of the parser code itself.\n *\n * @param headerName {String} The header name for which to get the header value.\n * @returns The structured header value of the output.\n */\nStructuredHeaders.prototype.get = function(headerName) {\n  // Normalize the header name to lower case\n  headerName = headerName.toLowerCase();\n\n  // First, check the cache for the header value\n  if (this._cachedHeaders.has(headerName)) {\n    return this._cachedHeaders.get(headerName);\n  }\n\n  // Not cached? Grab it [propagating lack of header to caller]\n  let headerValue = this._rawHeaders.get(headerName);\n  if (headerValue === undefined) {\n    return headerValue;\n  }\n\n  // Convert the header to Unicode\n  let charset = this.charset;\n  headerValue = headerValue.map(function(value) {\n    return headerparser.convert8BitHeader(value, charset);\n  });\n\n  // If there is a structured decoder, use that; otherwise, assume that the\n  // header is unstructured and only do RFC 2047 conversion\n  let structured;\n  try {\n    structured = headerparser.parseStructuredHeader(\n      headerName,\n      headerValue\n    );\n  } catch (e) {\n    structured = headerValue.map(function(value) {\n      return headerparser.decodeRFC2047Words(value);\n    });\n  }\n\n  // Cache the result and return it\n  this._cachedHeaders.set(headerName, structured);\n  return structured;\n};\n\n/**\n * Check if the message has the given header.\n *\n * @param headerName {String} The header name for which to get the header value.\n * @returns {Boolean} True if the header is present in this header block.\n */\nStructuredHeaders.prototype.has = function(headerName) {\n  // Check for presence in the raw headers instead of cached headers.\n  return this._rawHeaders.has(headerName.toLowerCase());\n};\n\n// Make a custom iterator. Presently, support for Symbol isn't yet present in\n// SpiderMonkey (or V8 for that matter), so type-pun the name for now.\nvar JS_HAS_SYMBOLS = typeof Symbol === \"function\";\nvar ITERATOR_SYMBOL = JS_HAS_SYMBOLS ? Symbol.iterator : \"@@iterator\";\n\n/**\n * An equivalent of Map.@@iterator, applied to the structured header\n * representations. This is the function that makes\n * for (let [header, value] of headers) work properly.\n */\nStructuredHeaders.prototype[ITERATOR_SYMBOL] = function*() {\n  // Iterate over all the raw headers, and use the cached headers to retrieve\n  // them.\n  for (let headerName of this.keys()) {\n    yield [headerName, this.get(headerName)];\n  }\n};\n\n/**\n * An equivalent of Map.forEach, applied to the structured header\n * representations.\n *\n * @param callback {Function(value, name, headers)} The callback to call for\n *                                                  each header/value combo.\n * @param thisarg  {Object}                         The parameter that will be\n *                                                  the |this| of the callback.\n */\nStructuredHeaders.prototype.forEach = function(callback, thisarg) {\n  for (let [header, value] of this) {\n    callback.call(thisarg, value, header, this);\n  }\n};\n\n/**\n * An equivalent of Map.entries, applied to the structured header\n * representations.\n */\nStructuredHeaders.prototype.entries =\n  StructuredHeaders.prototype[Symbol.iterator];\n\n// This function maps lower case names to a pseudo-preferred spelling.\nfunction capitalize(headerName) {\n  return headerName.replace(/\\b[a-z]/g, function(match) {\n    return match.toUpperCase();\n  });\n}\n\n/**\n * An equivalent of Map.keys, applied to the structured header representations.\n */\nStructuredHeaders.prototype.keys = function*() {\n  for (let name of this._rawHeaders.keys()) {\n    yield spellings.get(name) || capitalize(name);\n  }\n};\n\n/**\n * An equivalent of Map.values, applied to the structured header\n * representations.\n */\nStructuredHeaders.prototype.values = function*() {\n  for (let [, value] of this) {\n    yield value;\n  }\n};\n\n/**\n * A MIME parser.\n *\n * The inputs to the constructor consist of a callback object which receives\n * information about the output data and an optional object containing the\n * settings for the parser.\n *\n * The first parameter, emitter, is an object which contains several callbacks.\n * Note that any and all of these methods are optional; the parser will not\n * crash if one is missing. The callbacks are as follows:\n *   startMessage()\n *      Called when the stream to be parsed has started delivering data. This\n *      will be called exactly once, before any other call.\n *   endMessage()\n *      Called after all data has been delivered and the message parsing has\n *      been completed. This will be called exactly once, after any other call.\n *   startPart(string partNum, object headers)\n *      Called after the headers for a body part (including the top-level\n *      message) have been parsed. The first parameter is the part number (see\n *      the discussion on part numbering). The second parameter is an instance\n *      of StructuredHeaders that represents all of the headers for the part.\n *   endPart(string partNum)\n *      Called after all of the data for a body part (including sub-parts) has\n *      been parsed. The first parameter is the part number.\n *   deliverPartData(string partNum, {string,typedarray} data)\n *      Called when some data for a body part has been delivered. The first\n *      parameter is the part number. The second parameter is the data which is\n *      being delivered; the exact type of this data depends on the options\n *      used. Note that data is only delivered for leaf body parts.\n *\n *  The second parameter, options, is an optional object containing the options\n *  for the parser. The following are the options that the parser may use:\n *    pruneat: <string> [default=\"\"]\n *      Treat the message as starting at the given part number, so that no parts\n *      above <string> are returned.\n *    bodyformat: one of {none, raw, nodecode, decode} [default=nodecode]\n *      How to return the bodies of parts:\n *        none: no part data is returned\n *        raw: the body of the part is passed through raw\n *        nodecode: the body is passed through without decoding QP/Base64\n *        decode: quoted-printable and base64 are fully decoded\n *    strformat: one of {binarystring, unicode, typedarray} [default=binarystring]\n *      How to treat output strings:\n *        binarystring: Data is a JS string with chars in the range [\\x00-\\xff]\n *        unicode: Data for text parts is converted to UTF-16; data for other\n *          parts is a typed array buffer, akin to typedarray.\n *        typedarray: Data is a JS typed array buffer\n *    charset: <string> [default=\"\"]\n *      What charset to assume if no charset information is explicitly provided.\n *      This only matters if strformat is unicode. See above note on charsets\n *      for more details.\n *    force-charset: <boolean> [default=false]\n *      If true, this coerces all types to use the charset option, even if the\n *      message specifies a different content-type.\n *    stripcontinuations: <boolean> [default=true]\n *      If true, then the newlines in headers are removed in the returned\n *      header objects.\n *    onerror: <function(thrown error)> [default = nop-function]\n *      An error function that is called if an emitter callback throws an error.\n *      By default, such errors are swallowed by the parser. If you want the\n *      parser itself to throw an error, rethrow it via the onerror function.\n */\nfunction MimeParser(emitter, options) {\n  // The actual emitter\n  this._emitter = emitter;\n  // Options for the parser (those listed here are defaults)\n  this._options = {\n    pruneat: \"\",\n    bodyformat: \"nodecode\",\n    strformat: \"binarystring\",\n    stripcontinuations: true,\n    charset: \"\",\n    \"force-charset\": false,\n    onerror: () => {},\n  };\n  // Load the options as a copy here (prevents people from changing on the fly).\n  if (options) {\n    for (var opt in options) {\n      this._options[opt] = options[opt];\n    }\n  }\n\n  // Ensure that the error function is in fact a function\n  if (typeof this._options.onerror != \"function\") {\n    throw new Error(\"onerror callback must be a function\");\n  }\n\n  // Reset the parser\n  this.resetParser();\n}\n\n/**\n * Resets the parser to read a new message. This method need not be called\n * immediately after construction.\n */\nMimeParser.prototype.resetParser = function() {\n  // Current parser state\n  this._state = PARSING_HEADERS;\n  // Input data that needs to be held for buffer conditioning\n  this._holdData = \"\";\n  // Complete collection of headers (also used to accumulate _headerData)\n  this._headerData = \"\";\n  // Whether or not emitter.startMessage has been called\n  this._triggeredCall = false;\n\n  // Splitting input\n  this._splitRegex = this._handleSplit = undefined;\n  // Subparsing\n  this._subparser = this._subPartNum = undefined;\n  // Data that has yet to be consumed by _convertData\n  this._savedBuffer = \"\";\n  // Convert data\n  this._convertData = undefined;\n  // String decoder\n  this._decoder = undefined;\n};\n\n/**\n * Deliver a buffer of data to the parser.\n *\n * @param buffer {BinaryString} The raw data to add to the message.\n */\nMimeParser.prototype.deliverData = function(buffer) {\n  // In ideal circumstances, we'd like to parse the message all at once. In\n  // reality, though, data will be coming to us in packets. To keep the amount\n  // of saved state low, we want to make basic guarantees about how packets get\n  // delivered. Our basic model is a twist on line-buffering, as the format of\n  // MIME and messages make it hard to not do so: we can handle multiple lines\n  // at once. To ensure this, we start by conditioning the packet by\n  // withholding data to make sure that the internal deliveries have the\n  // guarantees. This implies that we need to do the following steps:\n  // 1. We don't know if a `\\r' comes from `\\r\\n' or the old mac line ending\n  // until we see the next character. So withhold the last `\\r'.\n  // 2. Ensure that every packet ends on a newline. So scan for the end of the\n  // line and withhold until the \\r\\n comes through.\n  // [Note that this means that an input message that uses \\r line endings and\n  // is being passed to us via a line-buffered input is going to have most of\n  // its data being withhold until the next buffer. Since \\r is so uncommon of\n  // a line ending in modern times, this is acceptable lossage.]\n  // 3. Eliminate empty packets.\n\n  // Add in previously saved data\n  if (this._holdData) {\n    buffer = this._holdData + buffer;\n    this._holdData = \"\";\n  }\n\n  // Condition the input, so that we get the multiline-buffering mentioned in\n  // the above comment.\n  if (buffer.length > 0) {\n    [buffer, this._holdData] = conditionToEndOnCRLF(buffer);\n  }\n\n  // Ignore 0-length buffers.\n  if (buffer.length == 0) {\n    return;\n  }\n\n  // Signal the beginning, if we haven't done so.\n  if (!this._triggeredCall) {\n    this._callEmitter(\"startMessage\");\n    this._triggeredCall = true;\n  }\n\n  // Finally, send it the internal parser.\n  this._dispatchData(\"\", buffer, true);\n};\n\n/**\n * Ensure that a set of data always ends in an end-of-line character.\n *\n * @param buffer {BinaryString} The data with no guarantees about where it ends.\n * @returns {BinaryString[]} An array of 2 binary strings where the first string\n *                           ends in a newline and the last string contains the\n *                           text in buffer following the first string.\n */\nfunction conditionToEndOnCRLF(buffer) {\n  // Find the last occurrence of '\\r' or '\\n' to split the string. However, we\n  // don't want to consider '\\r' if it is the very last character, as we need\n  // the next packet to tell if the '\\r' is the beginning of a CRLF or a line\n  // ending by itself.\n  let lastCR = buffer.lastIndexOf(\"\\r\", buffer.length - 2);\n  let lastLF = buffer.lastIndexOf(\"\\n\");\n  let end = lastLF > lastCR ? lastLF : lastCR;\n  return [buffer.substring(0, end + 1), buffer.substring(end + 1)];\n}\n\n/**\n * Tell the parser that all of the data has been delivered.\n *\n * This will flush all of the internal state of the parser.\n */\nMimeParser.prototype.deliverEOF = function() {\n  // Start of input buffered too long? Call start message now.\n  if (!this._triggeredCall) {\n    this._triggeredCall = true;\n    this._callEmitter(\"startMessage\");\n  }\n  // Force a flush of all of the data.\n  if (this._holdData) {\n    this._dispatchData(\"\", this._holdData, true);\n  }\n  this._dispatchEOF(\"\");\n  // Signal to the emitter that we're done.\n  this._callEmitter(\"endMessage\");\n};\n\n/**\n * Calls a method on the emitter safely.\n *\n * This method ensures that errors in the emitter call won't cause the parser\n * to exit with an error, unless the user wants it to.\n *\n * @param funcname {String} The function name to call on the emitter.\n * @param args...           Extra arguments to pass into the emitter callback.\n */\nMimeParser.prototype._callEmitter = function(funcname, ...args) {\n  if (this._emitter && funcname in this._emitter) {\n    if (args.length > 0 && this._willIgnorePart(args[0])) {\n      // partNum is always the first argument, so check to make sure that it\n      // satisfies our emitter's pruneat requirement.\n      return;\n    }\n    try {\n      this._emitter[funcname].apply(this._emitter, args);\n    } catch (e) {\n      // We ensure that the onerror attribute in options is a function, so this\n      // is always safe.\n      this._options.onerror(e);\n    }\n  }\n};\n\n/**\n * Helper function to decide if a part's output will never be seen.\n *\n * @param part {String} The number of the part.\n * @returns {Boolean} True if the emitter is not interested in this part.\n */\nMimeParser.prototype._willIgnorePart = function(part) {\n  if (this._options.pruneat) {\n    let match = this._options.pruneat;\n    let start = part.substr(0, match.length);\n    // It needs to start with and follow with a new part indicator\n    // (i.e., don't let 10 match with 1, but let 1.1 or 1$ do so)\n    if (\n      start != match ||\n      (match.length < part.length && !\"$.\".includes(part[match.length]))\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// MIME parser core\n// ----------------\n\n// This MIME parser is a stateful parser; handling of the MIME tree is mostly\n// done by creating new parsers and feeding data to them manually. In parallel\n// to the externally-visible deliverData and deliverEOF, the two methods\n// _dispatchData and _dispatchEOF are the internal counterparts that do the\n// main work of moving data to where it needs to go; helper functions are used\n// to handle translation.\n//\n// The overall flow of the parser is this. First, it buffers all of the data\n// until the dual-CRLF pattern is noticed. Once that is found, it parses the\n// entire header chunk at once. As a result of header parsing, the parser enters\n// one of three modes for handling data, and uses a special regex to change\n// modes and handle state changes. Specific details about the states the parser\n// can be in are as follows:\n//   PARSING_HEADERS: The input buffer is concatenated to the currently-received\n//     text, which is then searched for the CRLFCRLF pattern. If found, the data\n//     is split at this boundary; the first chunk is parsed using _parseHeaders,\n//     and the second chunk will fall through to buffer processing. After\n//     splitting, the headers are deliverd via the emitter, and _startBody is\n//     called to set up state for the parser.\n//   SEND_TO_BLACK_HOLE: All data in the input is ignored.\n//   SEND_TO_EMITTER: All data is passed into the emitter, if it is desired.\n//     Data can be optionally converted with this._convertData.\n//   SEND_TO_SUBPARSER: All data is passed into the subparser's _dispatchData\n//     method, using _subPartNum as the part number and _subparser as the object\n//     to call. Data can be optionally converted first with this._convertData.\n//\n// Additional state modifications can be done using a regex in _splitRegex and\n// the callback method this._handleSplit(partNum, regexResult). The _handleSplit\n// callback is free to do any modification to the current parser, including\n// modifying the _splitRegex value. Packet conditioning guarantees that every\n// buffer string passed into _dispatchData will have started immediately after a\n// newline character in the fully assembled message.\n//\n// The this._convertData method, if present, is expected to return an array of\n// two values, [{typedarray, string} decoded_buffer, string unused_buffer], and\n// has as its arguments (string buffer, bool moreToCome).\n//\n// The header parsing by itself does very little parsing, only parsing as if all\n// headers were unstructured fields. Values are munged so that embedded newlines\n// are stripped and the result is also trimmed. Headers themselves are\n// canonicalized into lower-case.\n\n// Parser states. See the large comment above.\nvar PARSING_HEADERS = 1;\nvar SEND_TO_BLACK_HOLE = 2;\nvar SEND_TO_EMITTER = 3;\nvar SEND_TO_SUBPARSER = 4;\n\n/**\n * Main dispatch for incoming packet data.\n *\n * The incoming data needs to have been sanitized so that each packet begins on\n * a newline boundary. The part number for the current parser also needs to be\n * passed in. The checkSplit parameter controls whether or not the data in\n * buffer needs to be checked against _splitRegex; this is used internally for\n * the mechanics of splitting and should otherwise always be true.\n *\n * @param partNum    {String}       The part number being currently parsed.\n * @param buffer     {BinaryString} The text (conditioned as mentioned above) to\n *                                  pass to the parser.\n * @param checkSplit {Boolean}      If true, split the text using _splitRegex.\n *                                  This is set to false internally to handle\n *                                  low-level splitting details.\n */\nMimeParser.prototype._dispatchData = function(partNum, buffer, checkSplit) {\n  // Are we parsing headers?\n  if (this._state == PARSING_HEADERS) {\n    this._headerData += buffer;\n    // Find the end of the headers--either it's a CRLF at the beginning (in\n    // which case we have no headers), or it's a pair of CRLFs.\n    let result = /(?:^(?:\\r\\n|[\\r\\n]))|(\\r\\n|[\\r\\n])\\1/.exec(\n      this._headerData\n    );\n    if (result != null) {\n      // If we found the end of headers, split the data at this point and send\n      // the stuff after the double-CRLF into the later body parsing.\n      let headers = this._headerData.substr(0, result.index);\n      buffer = this._headerData.substring(result.index + result[0].length);\n      this._headerData = headers;\n      this._headers = this._parseHeaders();\n      this._callEmitter(\"startPart\", partNum, this._headers);\n      this._startBody(partNum);\n    } else {\n      return;\n    }\n  }\n\n  // We're in the middle of the body. Start by testing the split regex, to see\n  // if there are many things that need to be done.\n  if (checkSplit && this._splitRegex) {\n    let splitResult = this._splitRegex.exec(buffer);\n    if (splitResult) {\n      // Pass the text before the split through the current state.\n      let start = splitResult.index,\n        len = splitResult[0].length;\n      if (start > 0) {\n        this._dispatchData(partNum, buffer.substr(0, start), false);\n      }\n\n      // Tell the handler that we've seen the split. Note that this can change\n      // any method on `this'.\n      this._handleSplit(partNum, splitResult);\n\n      // Send the rest of the data to where it needs to go. There could be more\n      // splits in the data, so watch out!\n      buffer = buffer.substring(start + len);\n      if (buffer.length > 0) {\n        this._dispatchData(partNum, buffer, true);\n      }\n      return;\n    }\n  }\n\n  // Where does the data go?\n  if (this._state == SEND_TO_BLACK_HOLE) {\n    // Don't send any data when going to the black hole.\n  } else if (this._state == SEND_TO_EMITTER) {\n    // Don't pass body data if the format is to be none\n    let passData = this._options.bodyformat != \"none\";\n    if (!passData || this._willIgnorePart(partNum)) {\n      return;\n    }\n    const { coerced, raw } = this._applyDataConversion(buffer, this._options.strformat);\n    this._callEmitter(\"deliverPartData\", partNum, coerced, raw);\n  } else if (this._state == SEND_TO_SUBPARSER) {\n    const { coerced } = this._applyDataConversion(buffer, \"binarystring\");\n    if (buffer.length > 0) {\n      this._subparser._dispatchData(this._subPartNum, coerced, true);\n    }\n  }\n};\n\n/**\n * Output data using the desired output format, saving data if data conversion\n * needs extra data to be saved.\n *\n * @param buf  {BinaryString} The data to be sent to the output.\n * @param type {String}       The type of the data to output. Valid values are\n *                            the same as the strformat option.\n * @returns Coerced and converted data that can be sent to the emitter or\n *          subparser.\n */\nMimeParser.prototype._applyDataConversion = function(buf, type) {\n  // If we need to convert data, do so.\n  if (this._convertData) {\n    // Prepend leftover data from the last conversion.\n    buf = this._savedBuffer + buf;\n    [buf, this._savedBuffer] = this._convertData(buf, true);\n  }\n  return {\n    coerced: this._coerceData(buf, type, false),\n    raw: buf instanceof Uint8Array ? buf : stringToUint8Array(buf)\n  };\n};\n\n/**\n * Coerce the input buffer into the given output type.\n *\n * @param buffer {BinaryString|Uint8Array} The data to be converted.\n * @param type   {String}                  The type to convert the data to.\n * @param more   {boolean}                 If true, this function will never be\n *                                         called again.\n * @returns {BinaryString|String|Uint8Array} The desired output format.\n */\n// Coerces the buffer (a string or typedarray) into a given type\nMimeParser.prototype._coerceData = function(buffer, type, more) {\n  if (typeof buffer == \"string\") {\n    // string -> binarystring is a nop\n    if (type == \"binarystring\") {\n      return buffer;\n    }\n    // Either we're going to array or unicode. Both people need the array\n    var typedarray = stringToUint8Array(buffer);\n    // If it's unicode, do the coercion from the array\n    // If its typedarray, just return the synthesized one\n    return type == \"unicode\"\n      ? this._coerceData(typedarray, \"unicode\", more)\n      : typedarray;\n  } else if (type == \"binarystring\") {\n    // Doing array -> binarystring\n    return uint8ArrayToString(buffer);\n  } else if (type == \"unicode\") {\n    // Doing array-> unicode: Use the decoder set up earlier to convert\n    if (this._decoder) {\n      return this._decoder.decode(buffer, { stream: more });\n    }\n    // If there is no charset, just return the typed array instead.\n    return buffer;\n  }\n  throw new Error(\"Invalid type: \" + type);\n};\n\n/**\n * Signal that no more data will be dispatched to this parser.\n *\n * @param partNum {String} The part number being currently parsed.\n */\nMimeParser.prototype._dispatchEOF = function(partNum) {\n  if (this._state == PARSING_HEADERS) {\n    // Unexpected EOF in headers. Parse them now and call startPart/endPart\n    this._headers = this._parseHeaders();\n    this._callEmitter(\"startPart\", partNum, this._headers);\n  } else if (this._state == SEND_TO_SUBPARSER) {\n    // Pass in any lingering data\n    if (this._convertData && this._savedBuffer) {\n      this._subparser._dispatchData(\n        this._subPartNum,\n        this._convertData(this._savedBuffer, false)[0],\n        true\n      );\n    }\n    this._subparser._dispatchEOF(this._subPartNum);\n    // Clean up after ourselves\n    this._subparser = null;\n  } else if (this._convertData && this._savedBuffer) {\n    // Convert lingering data\n    let [buffer] = this._convertData(this._savedBuffer, false);\n    buffer = this._coerceData(buffer, this._options.strformat, false);\n    if (buffer.length > 0) {\n      this._callEmitter(\"deliverPartData\", partNum, buffer);\n    }\n  }\n\n  // We've reached EOF for this part; tell the emitter\n  this._callEmitter(\"endPart\", partNum);\n};\n\n/**\n * Produce a dictionary of all headers as if they were unstructured fields.\n *\n * @returns {StructuredHeaders} The structured header objects for the header\n *                              block.\n */\nMimeParser.prototype._parseHeaders = function() {\n  let headers = new StructuredHeaders(this._headerData, this._options);\n\n  // Fill the headers.contentType parameter of headers.\n  let contentType = headers.get(\"Content-Type\");\n  if (typeof contentType === \"undefined\") {\n    contentType = headerparser.parseStructuredHeader(\n      \"Content-Type\",\n      this._defaultContentType || \"text/plain\"\n    );\n    Object.defineProperty(headers, \"contentType\", {\n      get() {\n        return contentType;\n      },\n    });\n  } else {\n    Object.defineProperty(headers, \"contentType\", { configurable: false });\n  }\n\n  // Find the charset for the current part. If the user requested a forced\n  // conversion, use that first. Otherwise, check the content-type for one and\n  // fallback to a default if it is not present.\n  let charset = \"\";\n  if (this._options[\"force-charset\"]) {\n    charset = this._options.charset;\n  } else if (contentType.has(\"charset\")) {\n    charset = contentType.get(\"charset\");\n  } else {\n    charset = this._options.charset;\n  }\n  headers.charset = charset;\n\n  // Retain a copy of the charset so that users don't override our decision for\n  // decoding body parts.\n  this._charset = charset;\n  return headers;\n};\n\n/**\n * Initialize the parser state for the body of this message.\n *\n * @param partNum {String} The part number being currently parsed.\n */\nMimeParser.prototype._startBody = function(partNum) {\n  let contentType = this._headers.contentType;\n\n  // Should the bodyformat be raw, we just want to pass through all data without\n  // trying to interpret it.\n  if (\n    this._options.bodyformat == \"raw\" &&\n    partNum == this._options.pruneat\n  ) {\n    this._state = SEND_TO_EMITTER;\n    return;\n  }\n\n  // The output depents on the content-type. Basic rule of thumb:\n  // 1. Discrete media types (text, video, audio, image, application) are passed\n  //    through with no alterations beyond Content-Transfer-Encoding unpacking.\n  // 2. Everything with a media type of multipart is treated the same.\n  // 3. Any message/* type that acts like a mail message (rfc822, news, global)\n  //    is parsed as a header/body pair again. Most of the other message/* types\n  //    have similar structures, but they don't have cascading child subparts,\n  //    so it's better to pass their entire contents to the emitter and let the\n  //    consumer deal with them.\n  // 4. For untyped data, there needs to be no Content-Type header. This helps\n  //    avoid false positives.\n  if (contentType.mediatype == \"multipart\") {\n    // If there's no boundary type, everything will be part of the prologue of\n    // the multipart message, so just feed everything into a black hole.\n    if (!contentType.has(\"boundary\")) {\n      this._state = SEND_TO_BLACK_HOLE;\n      return;\n    }\n    // The boundary of a multipart message needs to start with -- and be at the\n    // beginning of the line. If -- is after the boundary, it represents the\n    // terminator of the multipart. After the line, there may be only whitespace\n    // and then the CRLF at the end. Since the CRLFs in here are necessary for\n    // distinguishing the parts, they are not included in the subparts, so we\n    // need to capture them in the regex as well to prevent them leaking out.\n    this._splitRegex = new RegExp(\n      \"(\\r\\n|[\\r\\n]|^)--\" +\n        contentType.get(\"boundary\").replace(/[\\\\^$*+?.()|{}[\\]]/g, \"\\\\$&\") +\n        \"(--)?[ \\t]*(?:\\r\\n|[\\r\\n]|$)\"\n    );\n    this._handleSplit = this._whenMultipart;\n    this._subparser = new MimeParser(this._emitter, this._options);\n    // multipart/digest defaults to message/rfc822 instead of text/plain\n    if (contentType.subtype == \"digest\") {\n      this._subparser._defaultContentType = \"message/rfc822\";\n    }\n\n    // All text before the first boundary and after the closing boundary are\n    // supposed to be ignored (\"must be ignored\", according to RFC 2046 5.1.1);\n    // in accordance with these wishes, ensure they don't get passed to any\n    // deliverPartData.\n    this._state = SEND_TO_BLACK_HOLE;\n\n    // Multipart MIME messages stipulate that the final CRLF before the boundary\n    // delimiter is not matched. When the packet ends on a CRLF, we don't know\n    // if the next text could be the boundary. Therefore, we need to withhold\n    // the last line of text to be sure of what's going on. The _convertData is\n    // how we do this, even though we're not really converting any data.\n    this._convertData = function(buffer, more) {\n      let splitPoint = buffer.length;\n      if (more) {\n        if (buffer.charAt(splitPoint - 1) == \"\\n\") {\n          splitPoint--;\n        }\n        if (splitPoint >= 0 && buffer.charAt(splitPoint - 1) == \"\\r\") {\n          splitPoint--;\n        }\n      }\n      let res = conditionToEndOnCRLF(buffer.substring(0, splitPoint));\n      let preLF = res[0];\n      let rest = res[1];\n      return [preLF, rest + buffer.substring(splitPoint)];\n    };\n  } else if (\n    contentType.type == \"message/rfc822\" ||\n    contentType.type == \"message/global\" ||\n    contentType.type == \"message/news\"\n  ) {\n    // The subpart is just another header/body pair that goes to EOF, so just\n    // return the parse from that blob\n    this._state = SEND_TO_SUBPARSER;\n    this._subPartNum = partNum + \"$\";\n    this._subparser = new MimeParser(this._emitter, this._options);\n\n    // So, RFC 6532 happily allows message/global types to have CTE applied.\n    // This means that subparts would need to be decoded to determine their\n    // contents properly. There seems to be some evidence that message/rfc822\n    // that is illegally-encoded exists in the wild, so be lenient and decode\n    // for any message/* type that gets here.\n    let cte = this._extractHeader(\"content-transfer-encoding\", \"\");\n    if (cte in ContentDecoders) {\n      this._convertData = ContentDecoders[cte];\n    }\n  } else {\n    // Okay, we just have to feed the data into the output\n    this._state = SEND_TO_EMITTER;\n    if (this._options.bodyformat == \"decode\") {\n      // If we wish to decode, look it up in one of our decoders.\n      let cte = this._extractHeader(\"content-transfer-encoding\", \"\");\n      if (cte in ContentDecoders) {\n        this._convertData = ContentDecoders[cte];\n      }\n    }\n  }\n\n  // Set up the encoder for charset conversions; only do this for text parts.\n  // Other parts are almost certainly binary, so no translation should be\n  // applied to them.\n  if (\n    this._options.strformat == \"unicode\" &&\n    contentType.mediatype == \"text\"\n  ) {\n    // If the charset is nonempty, initialize the decoder\n    this._decoder = null;\n    if (this._charset !== \"\") {\n      try {\n        this._decoder = new MimeTextDecoder(this._charset);\n      } catch (e) {\n        console.error(e)\n      }\n    }\n    if (!this._decoder) {\n      // There's no charset we can use for decoding, so pass through as an\n      // identity encoder or otherwise this._coerceData will complain.\n      this._decoder = {\n        decode(buffer) {\n          return MimeParser.prototype._coerceData(\n            buffer,\n            \"binarystring\",\n            true\n          );\n        },\n      };\n    }\n  } else {\n    this._decoder = null;\n  }\n};\n\n// Internal split handling for multipart messages.\n/**\n * When a multipary boundary is found, handle the process of managing the\n * subparser state. This is meant to be used as a value for this._handleSplit.\n *\n * @param partNum    {String} The part number being currently parsed.\n * @param lastResult {Array}  The result of the regular expression match.\n */\nMimeParser.prototype._whenMultipart = function(partNum, lastResult) {\n  // Fix up the part number (don't do '' -> '.4' and don't do '1' -> '14')\n  if (partNum != \"\") {\n    partNum += \".\";\n  }\n  if (!this._subPartNum) {\n    // No count? This means that this is the first time we've seen the boundary,\n    // so do some initialization for later here.\n    this._count = 1;\n  } else {\n    // If we did not match a CRLF at the beginning of the line, strip CRLF from\n    // the saved buffer. We do this in the else block because it is not\n    // necessary for the prologue, since that gets ignored anyways.\n    if (this._savedBuffer != \"\" && lastResult[1] === \"\") {\n      let useEnd = this._savedBuffer.length - 1;\n      if (this._savedBuffer[useEnd] == \"\\n\") {\n        useEnd--;\n      }\n      if (useEnd >= 0 && this._savedBuffer[useEnd] == \"\\r\") {\n        useEnd--;\n      }\n      this._savedBuffer = this._savedBuffer.substring(0, useEnd + 1);\n    }\n    // If we have saved data and we matched a CRLF, pass the saved data in.\n    if (this._savedBuffer != \"\") {\n      this._subparser._dispatchData(\n        this._subPartNum,\n        this._savedBuffer,\n        true\n      );\n    }\n    // We've seen the boundary at least once before, so this must end a subpart.\n    // Tell that subpart that it has reached EOF.\n    this._subparser._dispatchEOF(this._subPartNum);\n  }\n  this._savedBuffer = \"\";\n\n  // The regex feeder has a capture on the (--)?, so if its result is present,\n  // then we have seen the terminator. Alternatively, the message may have been\n  // mangled to exclude the terminator, so also check if EOF has occurred.\n  if (lastResult[2] == undefined) {\n    this._subparser.resetParser();\n    this._state = SEND_TO_SUBPARSER;\n    this._subPartNum = partNum + this._count;\n    this._count += 1;\n  } else {\n    // Ignore the epilogue\n    this._splitRegex = null;\n    this._state = SEND_TO_BLACK_HOLE;\n  }\n};\n\n/**\n * Return the structured header from the current header block, or a default if\n * it is not present.\n *\n * @param name {String} The header name to get.\n * @param dflt {String} The default MIME value of the header.\n * @returns The structured representation of the header.\n */\nMimeParser.prototype._extractHeader = function(name, dflt) {\n  name = name.toLowerCase(); // Normalize name\n  return this._headers.has(name)\n    ? this._headers.get(name)\n    : headerparser.parseStructuredHeader(name, [dflt]);\n};\n\nvar ContentDecoders = {};\nContentDecoders[\"quoted-printable\"] = decode_qp;\nContentDecoders.base64 = decode_base64;\n\nexport default MimeParser;\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport headerParser from './headerParser';\nimport RawMimeParser from './rawMimeParser';\nimport { concatUint8Arrays, stringToUint8Array, uint8ArrayToString } from './utils';\n\n// Emitter helpers, for internal functions later on.\nvar ExtractMimeMsgEmitter = {\n  getAttachmentName(part) {\n    if (!part || !part[\"headers\"]) {\n      return \"\";\n    }\n\n    if (part.headers[\"content-disposition\"]) {\n      let filename = MimeParser.getParameter(\n        part.headers[\"content-disposition\"][0],\n        \"filename\"\n      );\n      if (filename) {\n        return filename;\n      }\n    }\n\n    if (part.headers[\"content-type\"]) {\n      let name = MimeParser.getParameter(\n        part.headers[\"content-type\"][0],\n        \"name\"\n      );\n      if (name) {\n        return name;\n      }\n    }\n\n    return \"\";\n  },\n\n  // All parts of content-disposition = \"attachment\" are returned as attachments.\n  // For content-disposition = \"inline\", all parts except those with content-type\n  // text/plain, text/html and text/enriched are returned as attachments.\n  isAttachment(part) {\n    if (!part) {\n      return false;\n    }\n\n    let contentType = part.contentType || \"text/plain\";\n    if (contentType.search(/^multipart\\//i) === 0) {\n      return false;\n    }\n\n    let contentDisposition = \"\";\n    if (\n      Array.isArray(part.headers[\"content-disposition\"]) &&\n      part.headers[\"content-disposition\"].length > 0\n    ) {\n      contentDisposition = part.headers[\"content-disposition\"][0];\n    }\n\n    if (\n      contentDisposition.search(/^attachment/i) === 0 ||\n      contentType.search(/^text\\/plain|^text\\/html|^text\\/enriched/i) === -1\n    ) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /** JSMime API **/\n  startMessage() {\n    this.mimeTree = {\n      partName: \"\",\n      contentType: \"message/rfc822\",\n      parts: [],\n      size: 0,\n      headers: {},\n      rawHeaderText: \"\",\n      allAttachments: [],\n      // keep track of encountered body parts, based on content-type\n      bodyParts: { text: [], html: [] },\n      // No support for encryption.\n      isEncrypted: false,\n    };\n    // partsPath is a hierarchical stack of parts from the root to the\n    // current part.\n    this.partsPath = [this.mimeTree];\n    this.options = this.options || {};\n  },\n\n  endMessage() {\n    // Prepare the mimeMsg object, which is the final output of the emitter.\n    this.mimeMsg = null;\n    if (this.mimeTree.parts.length == 0) {\n      return;\n    }\n\n    // Check if only a specific mime part has been requested.\n    if (this.options.getMimePart) {\n      if (this.mimeTree.parts[0].partName == this.options.getMimePart) {\n        this.mimeMsg = this.mimeTree.parts[0];\n        this.mimeMsg.bodyAsTypedArray = stringToUint8Array(\n          this.mimeMsg.body\n        );\n      }\n      return;\n    }\n\n    this.mimeMsg = this.mimeTree;\n  },\n\n  startPart(partNum, headerMap) {\n    let utf8Encoder = new TextEncoder();\n\n    let contentType = headerMap.contentType && headerMap.contentType.type\n      ? headerMap.contentType.type\n      : \"text/plain\";\n\n    let rawHeaderText = headerMap.rawHeaderText;\n\n    let headers = {};\n    for (let [headerName, headerValue] of headerMap._rawHeaders) {\n      // MsgHdrToMimeMessage always returns an array, even for single values.\n      let valueArray = Array.isArray(headerValue) ? headerValue : [headerValue];\n      // Return a binary string, to mimic MsgHdrToMimeMessage.\n      headers[headerName] = valueArray.map(value => {\n        let utf8ByteArray = utf8Encoder.encode(value);\n        return uint8ArrayToString(utf8ByteArray);\n      });\n    }\n\n    // Get the most recent part from the hierarchical parts stack, which is the\n    // parent of the new part to by added.\n    let currentPart = this.partsPath[this.partsPath.length - 1];\n\n    // Add a leading 1 to the partNum.\n    let partName = \"1\" + (partNum !== \"\" ? \".\" : \"\") + partNum;\n    if (partName == \"1\") {\n      // MsgHdrToMimeMessage differentiates between the message headers and the\n      // headers of the first part. jsmime.js however returns all headers of\n      // the message in the first part.\n\n      // Move rawHeaderText and add the content-* headers back to the new/first\n      // part.\n      currentPart.rawHeaderText = rawHeaderText;\n      rawHeaderText = rawHeaderText\n        .split(/\\n(?![ \\t])/)\n        .filter(h => h.toLowerCase().startsWith(\"content-\"))\n        .join(\"\\n\")\n        .trim();\n\n      // Move all headers and add the content-* headers back to the new/first\n      // part.\n      currentPart.headers = headers;\n      headers = Object.fromEntries(\n        Object.entries(headers).filter(h => h[0].startsWith(\"content-\"))\n      );\n    }\n\n    // Add default content-type header.\n    if (!headers[\"content-type\"]) {\n      headers[\"content-type\"] = [\"text/plain\"];\n    }\n\n    let newPart = {\n      partName,\n      rawBody: null, // Uint8Array\n      body: '', // string, coerced based on options\n      headers,\n      rawHeaderText,\n      contentType,\n      size: 0,\n      parts: [],\n      // No support for encryption.\n      isEncrypted: false,\n    };\n\n    // Add nested new part.\n    currentPart.parts.push(newPart);\n    // Update the newly added part to be current part.\n    this.partsPath.push(newPart);\n  },\n\n  endPart(partNum) {\n    let deleteBody = false;\n    // Get the most recent part from the hierarchical parts stack.\n    let currentPart = this.partsPath[this.partsPath.length - 1];\n\n    // Add size.\n    let size = currentPart.body.length;\n    currentPart.size += size;\n\n    if (this.isAttachment(currentPart)) {\n      currentPart.fileName = this.getAttachmentName(currentPart);\n      const contentDispositionHeader = currentPart.headers[\"content-disposition\"] && currentPart.headers[\"content-disposition\"][0];\n      const contentIdHeader = currentPart.headers[\"content-id\"] && currentPart.headers[\"content-id\"][0];\n\n      // the content-disposition header, as parsed by jsmime, also contains the filename\n      currentPart.contentDisposition = contentDispositionHeader ? contentDispositionHeader.split(';').shift() : undefined;\n      currentPart.contentId = contentIdHeader || undefined;\n\n      if (this.options.includeAttachments) {\n        this.mimeTree.allAttachments.push(currentPart);\n      } else {\n        deleteBody = true;\n      }\n    } else if (currentPart.rawBody) {\n      delete currentPart.rawBody; // drop Uint8Array data outside of attachments, to free up memory\n\n      const bodyType = currentPart.contentType || 'text/plain';\n      switch(bodyType) {\n        case 'text/html':\n          this.mimeTree.bodyParts.html.push(currentPart.body);\n          break;\n        case 'text/plain':\n          this.mimeTree.bodyParts.text.push(currentPart.body);\n          break;\n        // no support for rich text\n      }\n    }\n\n    if (deleteBody) {\n      delete currentPart.body;\n      delete currentPart.rawBody;\n    }\n\n    // Remove content-disposition and content-transfer-encoding headers.\n    currentPart.headers = Object.fromEntries(\n      Object.entries(currentPart.headers).filter(\n        h =>\n          ![\"content-disposition\", \"content-transfer-encoding\"].includes(h[0])\n      )\n    );\n\n    // Set the parent of this part to be the new current part.\n    this.partsPath.pop();\n\n    // Add the size of this part to its parent as well.\n    currentPart = this.partsPath[this.partsPath.length - 1];\n    currentPart.size += size;\n  },\n\n  /**\n   * The data parameter is either a string or a Uint8Array.\n   */\n  deliverPartData(partNum, data, rawData) {\n    // Get the most recent part from the hierarchical parts stack.\n    let currentPart = this.partsPath[this.partsPath.length - 1];\n\n    if (typeof data === \"string\") {\n      currentPart.body += data;\n    } else {\n      currentPart.body += uint8ArrayToString(data);\n    }\n\n    // we keep both raw and string data as at this point we do not know whether the part is an attachment\n    if (currentPart.rawBody === null) {\n      currentPart.rawBody = rawData;\n    } else {\n      currentPart.rawBody = concatUint8Arrays([currentPart.rawBody, rawData])\n    }\n  },\n};\n\nvar ExtractHeadersEmitter = {\n  startPart(partNum, headers) {\n    if (partNum == \"\") {\n      this.headers = headers;\n    }\n  },\n};\n\nvar ExtractHeadersAndBodyEmitter = {\n  body: \"\",\n  startPart: ExtractHeadersEmitter.startPart,\n  deliverPartData(partNum, data) {\n    if (partNum == \"\") {\n      this.body += data;\n    }\n  },\n};\n\nexport const MimeParser = {\n  /***\n   * Determine an arbitrary \"parameter\" part of a mail header.\n   *\n   * @param {string} headerStr - The string containing all parts of the header.\n   * @param {string} parameter - The parameter we are looking for.\n   *\n   *\n   * 'multipart/signed; protocol=\"xyz\"', 'protocol' --> returns \"xyz\"\n   *\n   * @return {string} String containing the value of the parameter; or \"\".\n   */\n\n  getParameter(headerStr, parameter) {\n    parameter = parameter.toLowerCase();\n    headerStr = headerStr.replace(/[\\r\\n]+[ \\t]+/g, \"\");\n\n    let hdrMap = headerParser.parseParameterHeader(\n      \";\" + headerStr,\n      true,\n      true\n    );\n\n    for (let [key, value] of hdrMap.entries()) {\n      if (parameter == key.toLowerCase()) {\n        return value;\n      }\n    }\n\n    return \"\";\n  },\n\n  /**\n   * Triggers an synchronous parse of the given input.\n   *\n   * The input is a string that is immediately parsed, calling all functions on\n   * the emitter before this function returns.\n   *\n   * @param {BinaryString} input   A string or input stream of text to parse.\n   * @param emitter The emitter to receive callbacks on.\n   * @param opts    A set of options for the parser.\n   */\n  parseSync(input, emitter, opts) {\n    // We only support string parsing if we are trying to do this parse\n    // synchronously.\n    if (typeof input != \"string\") {\n      throw new Error(\"input is not a recognizable type!\");\n    }\n    var parser = new RawMimeParser(emitter, opts);\n    parser.deliverData(input);\n    parser.deliverEOF();\n  },\n\n  /**\n   * Returns a stream listener that feeds data into a parser.\n   *\n   * In addition to the functions on the emitter that the parser may use, the\n   * generated stream listener will also make calls to onStartRequest and\n   * onStopRequest on the emitter (if they exist).\n   *\n   * @param emitter The emitter to receive callbacks on.\n   * @param opts    A set of options for the parser.\n   */\n  // makeStreamListenerParser(emitter, opts) {\n  //   var StreamListener = {\n  //     onStartRequest(aRequest) {\n  //       try {\n  //         if (\"onStartRequest\" in emitter) {\n  //           emitter.onStartRequest(aRequest);\n  //         }\n  //       } finally {\n  //         this._parser.resetParser();\n  //       }\n  //     },\n  //     onStopRequest(aRequest, aStatus) {\n  //       this._parser.deliverEOF();\n  //       if (\"onStopRequest\" in emitter) {\n  //         emitter.onStopRequest(aRequest, aStatus);\n  //       }\n  //     },\n  //     onDataAvailable(aRequest, aStream, aOffset, aCount) {\n  //       var scriptIn = Cc[\n  //         \"@mozilla.org/scriptableinputstream;1\"\n  //       ].createInstance(Ci.nsIScriptableInputStream);\n  //       scriptIn.init(aStream);\n  //       // Use readBytes instead of read to handle embedded NULs properly.\n  //       this._parser.deliverData(scriptIn.readBytes(aCount));\n  //     },\n  //     QueryInterface: ChromeUtils.generateQI([\n  //       \"nsIStreamListener\",\n  //       \"nsIRequestObserver\",\n  //     ]),\n  //   };\n  //   setDefaultParserOptions(opts);\n  //   StreamListener._parser = new RawMimeParser(emitter, opts);\n  //   return StreamListener;\n  // },\n\n  /**\n   * Returns a new raw MIME parser.\n   *\n   * Prefer one of the other methods where possible, since the input here must\n   * be driven manually.\n   *\n   * @param emitter The emitter to receive callbacks on.\n   * @param opts    A set of options for the parser.\n   */\n  makeParser(emitter, opts) {\n    return new RawMimeParser(emitter, opts);\n  },\n\n  /**\n   * Returns a mimeMsg object for the given input. The returned object tries to\n   * be compatible with the return value of MsgHdrToMimeMessage. Differences:\n   *  - no support for encryption\n   *  - calculated sizes differ slightly\n   *  - allAttachments includes the content and not a URL\n   *  - does not eat TABs in headers, if they follow a CRLF\n   *\n   * The input is any type of input that would be accepted by parseSync.\n   *\n   * @param {BinaryString} input   A string of text to parse.\n   */\n  extractMimeMsg(input, options = {}) {\n    var emitter = Object.create(ExtractMimeMsgEmitter);\n    // Set default options.\n    emitter.options = {\n      includeAttachments: true,\n      getMimePart: \"\",\n    };\n    // Override default options.\n    for (let option of Object.keys(options)) {\n      emitter.options[option] = options[option];\n    }\n\n    MimeParser.parseSync(input, emitter, {\n      // jsmime does not use the \"1.\" prefix for the partName.\n      pruneat: emitter.options.getMimePart\n        .split(\".\")\n        .slice(1)\n        .join(\".\"),\n      bodyformat: \"decode\",\n      stripcontinuations: true,\n      strformat: \"unicode\",\n    });\n    return emitter.mimeMsg;\n  },\n\n  /**\n   * Returns a dictionary of headers for the given input.\n   *\n   * The input is any type of input that would be accepted by parseSync. What\n   * is returned is a JS object that represents the headers of the entire\n   * envelope as would be received by startPart when partNum is the empty\n   * string.\n   *\n   * @param input   A string of text to parse.\n   */\n  extractHeaders(input) {\n    var emitter = Object.create(ExtractHeadersEmitter);\n    MimeParser.parseSync(input, emitter, { pruneat: \"\", bodyformat: \"none\" });\n    return emitter.headers;\n  },\n\n  /**\n   * Returns the headers and body for the given input message.\n   *\n   * The return value is an array whose first element is the dictionary of\n   * headers (as would be returned by extractHeaders) and whose second element\n   * is a binary string of the entire body of the message.\n   *\n   * @param input   A string of text to parse.\n   */\n  extractHeadersAndBody(input) {\n    var emitter = Object.create(ExtractHeadersAndBodyEmitter);\n    MimeParser.parseSync(input, emitter, { pruneat: \"\", bodyformat: \"raw\" });\n    return [emitter.headers, emitter.body];\n  },\n\n  // Parameters for parseHeaderField\n\n  /**\n   * Parse the header as if it were unstructured.\n   *\n   * This results in the same string if no other options are specified. If other\n   * options are specified, this causes the string to be modified appropriately.\n   */\n  HEADER_UNSTRUCTURED: 0x00,\n  /**\n   * Parse the header as if it were in the form text; attr=val; attr=val.\n   *\n   * Such headers include Content-Type, Content-Disposition, and most other\n   * headers used by MIME as opposed to messages.\n   */\n  HEADER_PARAMETER: 0x02,\n  /**\n   * Parse the header as if it were a sequence of mailboxes.\n   */\n  HEADER_ADDRESS: 0x03,\n\n  /**\n   * This decodes parameter values according to RFC 2231.\n   *\n   * This flag means nothing if HEADER_PARAMETER is not specified.\n   */\n  HEADER_OPTION_DECODE_2231: 0x10,\n  /**\n   * This decodes the inline encoded-words that are in RFC 2047.\n   */\n  HEADER_OPTION_DECODE_2047: 0x20,\n  /**\n   * This converts the header from a raw string to proper Unicode.\n   */\n  HEADER_OPTION_ALLOW_RAW: 0x40,\n\n  // Convenience for all three of the above.\n  HEADER_OPTION_ALL_I18N: 0x70,\n\n  /**\n   * Parse a header field according to the specification given by flags.\n   *\n   * Permissible flags begin with one of the HEADER_* flags, which may be or'd\n   * with any of the HEADER_OPTION_* flags to modify the result appropriately.\n   *\n   * If the option HEADER_OPTION_ALLOW_RAW is passed, the charset parameter, if\n   * present, is the charset to fallback to if the header is not decodable as\n   * UTF-8 text. If HEADER_OPTION_ALLOW_RAW is passed but the charset parameter\n   * is not provided, then no fallback decoding will be done. If\n   * HEADER_OPTION_ALLOW_RAW is not passed, then no attempt will be made to\n   * convert charsets.\n   *\n   * @param text    The value of a MIME or message header to parse.\n   * @param flags   A set of flags that controls interpretation of the header.\n   * @param charset A default charset to assume if no information may be found.\n   */\n  parseHeaderField(text, flags, charset) {\n    // If we have a raw string, convert it to Unicode first\n    if (flags & MimeParser.HEADER_OPTION_ALLOW_RAW) {\n      text = headerParser.convert8BitHeader(text, charset);\n    }\n\n    // The low 4 bits indicate the type of the header we are parsing. All of the\n    // higher-order bits are flags.\n    switch (flags & 0x0f) {\n      case MimeParser.HEADER_UNSTRUCTURED:\n        if (flags & MimeParser.HEADER_OPTION_DECODE_2047) {\n          text = headerParser.decodeRFC2047Words(text);\n        }\n        return text;\n      case MimeParser.HEADER_PARAMETER:\n        return headerParser.parseParameterHeader(\n          text,\n          (flags & MimeParser.HEADER_OPTION_DECODE_2047) != 0,\n          (flags & MimeParser.HEADER_OPTION_DECODE_2231) != 0\n        );\n      case MimeParser.HEADER_ADDRESS:\n        return headerParser.parseAddressingHeader(\n          text,\n          (flags & MimeParser.HEADER_OPTION_DECODE_2047) != 0\n        );\n      default:\n        throw new Error(\"Illegal type of header field\");\n    }\n  },\n};\n\n/**\n * Parse MIME message\n * @param {String|Uint8Array} data - MIME message to parse\n * @returns {Object} parsed content (see TS definitions for more details)\n */\nexport function parseMail(data) {\n  const encoded = (typeof data === 'string') ? new TextEncoder().encode(data) : data;\n\n  const { headers, allAttachments, bodyParts } = MimeParser.extractMimeMsg(uint8ArrayToString(encoded));\n  // these fields can only contain a single value\n  const singleKeys = new Set([\n    'message-id',\n    'content-id',\n    'from',\n    'sender',\n    'in-reply-to',\n    'reply-to',\n    'subject',\n    'date',\n    'content-disposition',\n    'content-type',\n    'content-transfer-encoding',\n    'priority',\n    'mime-version',\n    'content-description',\n    'precedence',\n    'errors-to'\n  ]);\n\n  const mail = {\n    headers,\n    // drop some fields for each attachment.\n    // also, and convert a `null` rawBody to an empty array (edge-case when passing only the attachment headers as `data`)\n    attachments: allAttachments.map(\n      ({ parts, partName, body, isEncrypted, rawBody, ...rest }) => ({ ...rest, content: rawBody || new Uint8Array() })\n    ),\n    // join all body parts and normalise EOL to \\n\n    body: {\n      html: bodyParts.html.length ? bodyParts.html.join('<br>\\n').replace(/\\r?\\n/g, '\\n') : null,\n      text: bodyParts.text.length ? bodyParts.text.join('\\n').replace(/\\r?\\n/g, '\\n') : null\n    },\n  };\n\n  // copy some headers into top-level object\n  ['subject', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(key => {\n    if (!headers[key]) return;\n    const maybeArrayValue = headers[key] && headerParser.parseStructuredHeader(key, headers[key]);\n    mail[key] = singleKeys.has(key) && Array.isArray(maybeArrayValue)\n      ? maybeArrayValue[maybeArrayValue.length - 1]\n      : maybeArrayValue;\n  });\n\n  return mail;\n}\n"],"names":["decode_qp","buffer","replace","match","param","trim","length","String","fromCharCode","parseInt","decode_base64","more","sanitize","excess","slice","substring","atob","stringToUint8Array","typedarray","Uint8Array","i","charCodeAt","uint8ArrayToString","string","apply","undefined","subarray","kMonthNames","UTF7TextDecoder","constructor","this","collectInput","decodeString","decodeUtf7","decode","input","options","stream","UTF7ImapTextDecoder","super","decodeUtf7Imap","MimeTextDecoder","charset","toLowerCase","TextDecoder","decodeFromUTF7","str","octets","output","len","_","chunk","structuredDecoders","Map","structuredEncoders","preferredSpellings","addHeader","name","decoder","encoder","lowerName","set","parseAddress","value","headerparser","reduce","results","header","concat","parseAddressingHeader","writeAddress","Array","isArray","addAddresses","parseParameterHeader","do2231","do2047","parseUnstructured","values","decodeRFC2047Words","writeUnstructured","addUnstructured","parseMessageID","writeMessageID","parseDate","parseDateHeader","writeDate","addDate","preprocessMessageIDs","msgId","ids","exec","push","join","params","call","parts","preSemi","split","mediatype","subtype","type","structure","forEach","cleanToken","token","getHeaderTokens","delimiters","opts","tokenStart","tokenList","Token","prototype","toString","endQuote","commentDepth","ch","text","rfc2047","result","encWordsLen","tokenIsEnding","tokenIsStarting","isSpecial","includes","qstring","dliteral","comments","headerValue","currentDecoder","lastCharset","decode2047Token","isLastToken","tokenParts","encoding","stringBuffer","fatal","e","doStreaming","toUpperCase","endsWith","components","lastRFC2047Index","decoded","decode2231Value","quote1","indexOf","quote2","Math","max","kKnownTZs","UT","GMT","EST","EDT","CST","CDT","MST","MDT","PST","PDT","AST","NST","BST","MET","EET","JST","forbiddenHeaders","Set","pair","addStructuredDecoder","add","lowerHeader","has","Error","convert8BitHeader","fallbackCharset","utf8Decoder","startsWith","ex","doRFC2047","addrlist","groupName","localPart","address","comment","inAngle","inComment","needsSpace","afterAddress","preserveSpace","commentClosed","lastComment","addToAddrList","displayName","addrSpec","lp","lastIndexOf","offset","substr","email","spacedToken","group","tokens","map","x","Date","NaN","day","year","hours","minutes","seconds","month","tzoffset","decompose","tzOffsetInMin","UTC","doRFC2231","semi","start","rest","inName","matches","hexchars","simpleValues","charsetValues","continuationValues","star","entry","get","valid","hasCharset","lastStar","number","test","parseStructuredHeader","TypeError","Object","freeze","StructuredHeaders","rawHeaderText","shift","headers","val","colon","stripcontinuations","_rawHeaders","_cachedHeaders","defineProperty","size","_charset","clear","configurable","getRawHeader","headerName","structured","ITERATOR_SYMBOL","Symbol","iterator","MimeParser","emitter","_emitter","_options","pruneat","bodyformat","strformat","onerror","opt","resetParser","conditionToEndOnCRLF","lastCR","lastLF","end","keys","callback","thisarg","entries","_state","PARSING_HEADERS","_holdData","_headerData","_triggeredCall","_splitRegex","_handleSplit","_subparser","_subPartNum","_savedBuffer","_convertData","_decoder","deliverData","_callEmitter","_dispatchData","deliverEOF","_dispatchEOF","funcname","args","_willIgnorePart","part","partNum","checkSplit","index","_headers","_parseHeaders","_startBody","splitResult","coerced","raw","_applyDataConversion","buf","_coerceData","contentType","_defaultContentType","RegExp","_whenMultipart","splitPoint","charAt","res","cte","_extractHeader","ContentDecoders","console","error","lastResult","useEnd","_count","dflt","base64","ExtractMimeMsgEmitter","getAttachmentName","filename","getParameter","isAttachment","search","contentDisposition","startMessage","mimeTree","partName","allAttachments","bodyParts","html","isEncrypted","partsPath","endMessage","mimeMsg","getMimePart","bodyAsTypedArray","body","startPart","headerMap","utf8Encoder","TextEncoder","valueArray","encode","currentPart","filter","h","fromEntries","newPart","rawBody","endPart","deleteBody","fileName","contentDispositionHeader","contentIdHeader","contentId","includeAttachments","pop","deliverPartData","data","rawData","arrays","totalLength","pos","element","concatUint8Arrays","ExtractHeadersEmitter","ExtractHeadersAndBodyEmitter","headerStr","parameter","hdrMap","headerParser","key","parseSync","parser","makeParser","extractMimeMsg","create","option","extractHeaders","extractHeadersAndBody","HEADER_UNSTRUCTURED","HEADER_PARAMETER","HEADER_ADDRESS","HEADER_OPTION_DECODE_2231","HEADER_OPTION_DECODE_2047","HEADER_OPTION_ALLOW_RAW","HEADER_OPTION_ALL_I18N","parseHeaderField","flags","parseMail","encoded","singleKeys","mail","attachments","content","maybeArrayValue"],"sourceRoot":""}