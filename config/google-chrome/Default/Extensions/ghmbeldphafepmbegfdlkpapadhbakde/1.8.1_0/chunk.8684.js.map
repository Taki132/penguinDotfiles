{"version":3,"file":"chunk.8684.js","mappings":"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","sources":["webpack://proton-pass-extension/../../node_modules/@openpgp/noble-hashes/esm/biginteger/interface.js","webpack://proton-pass-extension/../../node_modules/@openpgp/noble-hashes/esm/biginteger/native.interface.js"],"sourcesContent":["class BigInteger {\n    static setImplementation(Implementation, replace = false) {\n        if (BigInteger.Implementation && !replace) {\n            throw new Error('Implementation already set');\n        }\n        BigInteger.Implementation = Implementation;\n    }\n    static new(n) {\n        return new BigInteger.Implementation(n);\n    }\n}\nexport { BigInteger, BigInteger as default };\n//# sourceMappingURL=interface.js.map","/**\n * @fileoverview\n * BigInteger implementation of basic operations\n * that wraps the native BigInt library.\n * Operations are not constant time,\n * but we try and limit timing leakage where we can\n * @module biginteger/native\n * @private\n */\nimport AbstractBigInteger from './interface.js';\n/**\n * @private\n */\nexport default class NativeBigInteger extends AbstractBigInteger {\n    /**\n     * Get a BigInteger (input must be big endian for strings and arrays)\n     * @param {Number|String|Uint8Array} n - Value to convert\n     * @throws {Error} on null or undefined input\n     */\n    constructor(n) {\n        super(); // noop, needed for TS checks only\n        if (n === undefined) {\n            throw new Error('Invalid BigInteger input');\n        }\n        if (n instanceof Uint8Array) {\n            const bytes = n;\n            const hexAlphabet = '0123456789ABCDEF';\n            let s = '';\n            bytes.forEach((v) => {\n                s += hexAlphabet[v >> 4] + hexAlphabet[v & 15];\n            });\n            this.value = BigInt('0x0' + s);\n        }\n        else {\n            this.value = BigInt(n);\n        }\n    }\n    clone() {\n        return new NativeBigInteger(this.value);\n    }\n    /**\n     * BigInteger increment in place\n     */\n    iinc() {\n        this.value++;\n        return this;\n    }\n    /**\n     * BigInteger increment\n     * @returns {BigInteger} this + 1.\n     */\n    inc() {\n        return this.clone().iinc();\n    }\n    /**\n     * BigInteger decrement in place\n     */\n    idec() {\n        this.value--;\n        return this;\n    }\n    /**\n     * BigInteger decrement\n     * @returns {BigInteger} this - 1.\n     */\n    dec() {\n        return this.clone().idec();\n    }\n    /**\n     * BigInteger addition in place\n     * @param {BigInteger} x - Value to add\n     */\n    iadd(x) {\n        this.value += x.value;\n        return this;\n    }\n    /**\n     * BigInteger addition\n     * @param {BigInteger} x - Value to add\n     * @returns {BigInteger} this + x.\n     */\n    add(x) {\n        return this.clone().iadd(x);\n    }\n    /**\n     * BigInteger subtraction in place\n     * @param {BigInteger} x - Value to subtract\n     */\n    isub(x) {\n        this.value -= x.value;\n        return this;\n    }\n    /**\n     * BigInteger subtraction\n     * @param {BigInteger} x - Value to subtract\n     * @returns {BigInteger} this - x.\n     */\n    sub(x) {\n        return this.clone().isub(x);\n    }\n    /**\n     * BigInteger multiplication in place\n     * @param {BigInteger} x - Value to multiply\n     */\n    imul(x) {\n        this.value *= x.value;\n        return this;\n    }\n    /**\n     * BigInteger multiplication\n     * @param {BigInteger} x - Value to multiply\n     * @returns {BigInteger} this * x.\n     */\n    mul(x) {\n        return this.clone().imul(x);\n    }\n    /**\n     * Compute value modulo m, in place\n     * @param {BigInteger} m - Modulo\n     */\n    imod(m) {\n        this.value %= m.value;\n        if (this.isNegative()) {\n            this.iadd(m);\n        }\n        return this;\n    }\n    /**\n     * Compute value modulo m\n     * @param {BigInteger} m - Modulo\n     * @returns {BigInteger} this mod m.\n     */\n    mod(m) {\n        return this.clone().imod(m);\n    }\n    /**\n     * Compute modular exponentiation using square and multiply\n     * @param {BigInteger} e - Exponent\n     * @param {BigInteger} n - Modulo\n     * @returns {BigInteger} this ** e mod n.\n     */\n    modExp(e, n) {\n        if (n.isZero())\n            throw Error('Modulo cannot be zero');\n        if (n.isOne())\n            return new NativeBigInteger(0);\n        if (e.isNegative())\n            throw Error('Unsopported negative exponent');\n        let exp = e.value;\n        let x = this.value;\n        x %= n.value;\n        let r = BigInt(1);\n        while (exp > BigInt(0)) {\n            const lsb = exp & BigInt(1);\n            exp >>= BigInt(1); // e / 2\n            // Always compute multiplication step, to reduce timing leakage\n            const rx = (r * x) % n.value;\n            // Update r only if lsb is 1 (odd exponent)\n            r = lsb ? rx : r;\n            x = (x * x) % n.value; // Square\n        }\n        return new NativeBigInteger(r);\n    }\n    /**\n     * Compute the inverse of this value modulo n\n     * Note: this and and n must be relatively prime\n     * @param {BigInteger} n - Modulo\n     * @returns {BigInteger} x such that this*x = 1 mod n\n     * @throws {Error} if the inverse does not exist\n     */\n    modInv(n) {\n        const { gcd, x } = this._egcd(n);\n        if (!gcd.isOne()) {\n            throw new Error('Inverse does not exist');\n        }\n        return x.add(n).mod(n);\n    }\n    /**\n     * Extended Eucleadian algorithm (http://anh.cs.luc.edu/331/notes/xgcd.pdf)\n     * Given a = this and b, compute (x, y) such that ax + by = gdc(a, b)\n     * @param {BigInteger} b - Second operand\n     * @returns {{ gcd, x, y: BigInteger }}\n     */\n    _egcd(bInput) {\n        let x = BigInt(0);\n        let y = BigInt(1);\n        let xPrev = BigInt(1);\n        let yPrev = BigInt(0);\n        let a = this.value;\n        let b = bInput.value;\n        while (b !== BigInt(0)) {\n            const q = a / b;\n            let tmp = x;\n            x = xPrev - q * x;\n            xPrev = tmp;\n            tmp = y;\n            y = yPrev - q * y;\n            yPrev = tmp;\n            tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return {\n            x: new NativeBigInteger(xPrev),\n            y: new NativeBigInteger(yPrev),\n            gcd: new NativeBigInteger(a),\n        };\n    }\n    /**\n     * Compute greatest common divisor between this and n\n     * @param {BigInteger} b - Operand\n     * @returns {BigInteger} gcd\n     */\n    gcd(bInput) {\n        let a = this.value;\n        let b = bInput.value;\n        while (b !== BigInt(0)) {\n            const tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return new NativeBigInteger(a);\n    }\n    /**\n     * Shift this to the left by x, in place\n     * @param {BigInteger} x - Shift value\n     */\n    ileftShift(x) {\n        this.value <<= x.value;\n        return this;\n    }\n    /**\n     * Shift this to the left by x\n     * @param {BigInteger} x - Shift value\n     * @returns {BigInteger} this << x.\n     */\n    leftShift(x) {\n        return this.clone().ileftShift(x);\n    }\n    /**\n     * Shift this to the right by x, in place\n     * @param {BigInteger} x - Shift value\n     */\n    irightShift(x) {\n        this.value >>= x.value;\n        return this;\n    }\n    /**\n     * Shift this to the right by x\n     * @param {BigInteger} x - Shift value\n     * @returns {BigInteger} this >> x.\n     */\n    rightShift(x) {\n        return this.clone().irightShift(x);\n    }\n    ixor(x) {\n        this.value ^= x.value;\n        return this;\n    }\n    ibitwiseAnd(x) {\n        this.value &= x.value;\n        return this;\n    }\n    bitwiseAnd(x) {\n        return this.clone().ibitwiseAnd(x);\n    }\n    ibitwiseOr(x) {\n        this.value |= x.value;\n        return this;\n    }\n    /**\n     * Whether this value is equal to x\n     * @param {BigInteger} x\n     * @returns {Boolean}\n     */\n    equal(x) {\n        return this.value === x.value;\n    }\n    /**\n     * Whether this value is less than x\n     * @param {BigInteger} x\n     * @returns {Boolean}\n     */\n    lt(x) {\n        return this.value < x.value;\n    }\n    /**\n     * Whether this value is less than or equal to x\n     * @param {BigInteger} x\n     * @returns {Boolean}\n     */\n    lte(x) {\n        return this.value <= x.value;\n    }\n    /**\n     * Whether this value is greater than x\n     * @param {BigInteger} x\n     * @returns {Boolean}\n     */\n    gt(x) {\n        return this.value > x.value;\n    }\n    /**\n     * Whether this value is greater than or equal to x\n     * @param {BigInteger} x\n     * @returns {Boolean}\n     */\n    gte(x) {\n        return this.value >= x.value;\n    }\n    isZero() {\n        return this.value === BigInt(0);\n    }\n    isOne() {\n        return this.value === BigInt(1);\n    }\n    isNegative() {\n        return this.value < BigInt(0);\n    }\n    isEven() {\n        return !(this.value & BigInt(1));\n    }\n    abs() {\n        const res = this.clone();\n        if (this.isNegative()) {\n            res.value = -res.value;\n        }\n        return res;\n    }\n    /**\n     * Get this value as a string\n     * @returns {String} this value.\n     */\n    toString() {\n        return this.value.toString();\n    }\n    /**\n     * Get this value as an exact Number (max 53 bits)\n     * Fails if this value is too large\n     * @returns {Number}\n     */\n    toNumber() {\n        const number = Number(this.value);\n        if (number > Number.MAX_SAFE_INTEGER) {\n            // We throw and error to conform with the bn.js implementation\n            throw new Error('Number can only safely store up to 53 bits');\n        }\n        return number;\n    }\n    /**\n     * Get value of i-th bit\n     * @param {Number} i - Bit index\n     * @returns {Number} Bit value.\n     */\n    getBit(i) {\n        const bit = (this.value >> BigInt(i)) & BigInt(1);\n        return bit === BigInt(0) ? 0 : 1;\n    }\n    /**\n     * Compute bit length\n     * @returns {Number} Bit length.\n     */\n    bitLength() {\n        const zero = new NativeBigInteger(0);\n        const one = new NativeBigInteger(1);\n        const negOne = new NativeBigInteger(-1);\n        // -1n >> -1n is -1n\n        // 1n >> 1n is 0n\n        const target = this.isNegative() ? negOne : zero;\n        let bitlen = 1;\n        const tmp = this.clone();\n        while (!tmp.irightShift(one).equal(target)) {\n            bitlen++;\n        }\n        return bitlen;\n    }\n    /**\n     * Compute byte length\n     * @returns {Number} Byte length.\n     */\n    byteLength() {\n        const zero = new NativeBigInteger(0);\n        const negOne = new NativeBigInteger(-1);\n        const target = this.isNegative() ? negOne : zero;\n        const eight = new NativeBigInteger(8);\n        let len = 1;\n        const tmp = this.clone();\n        while (!tmp.irightShift(eight).equal(target)) {\n            len++;\n        }\n        return len;\n    }\n    /**\n     * Get Uint8Array representation of this number\n     * @param {String} endian - Endianess of output array (defaults to 'be')\n     * @param {Number} length - Of output array\n     * @returns {Uint8Array}\n     */\n    toUint8Array(endian = 'be', length) {\n        // we get and parse the hex string (https://coolaj86.com/articles/convert-js-bigints-to-typedarrays/)\n        // this is faster than shift+mod iterations\n        let hex = this.value.toString(16);\n        if (hex.length % 2 === 1) {\n            hex = '0' + hex;\n        }\n        const rawLength = hex.length / 2;\n        const bytes = new Uint8Array(length || rawLength);\n        // parse hex\n        const offset = length ? length - rawLength : 0;\n        let i = 0;\n        while (i < rawLength) {\n            bytes[i + offset] = parseInt(hex.slice(2 * i, 2 * i + 2), 16);\n            i++;\n        }\n        if (endian !== 'be') {\n            bytes.reverse();\n        }\n        return bytes;\n    }\n}\n//# sourceMappingURL=native.interface.js.map"],"names":["BigInteger","setImplementation","Implementation","replace","Error","n","NativeBigInteger","constructor","super","undefined","Uint8Array","hexAlphabet","s","forEach","v","this","value","BigInt","clone","iinc","inc","idec","dec","iadd","x","add","isub","sub","imul","mul","imod","m","isNegative","mod","modExp","e","isZero","isOne","exp","r","lsb","rx","modInv","gcd","_egcd","bInput","y","xPrev","yPrev","a","b","q","tmp","ileftShift","leftShift","irightShift","rightShift","ixor","ibitwiseAnd","bitwiseAnd","ibitwiseOr","equal","lt","lte","gt","gte","isEven","abs","res","toString","toNumber","number","Number","MAX_SAFE_INTEGER","getBit","i","bitLength","zero","one","negOne","target","bitlen","byteLength","eight","len","toUint8Array","endian","length","hex","rawLength","bytes","offset","parseInt","slice","reverse"],"sourceRoot":""}